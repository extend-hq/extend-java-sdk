/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.utilities.polling;

import static org.junit.jupiter.api.Assertions.*;

import ai.extend.wrapper.errors.PollingTimeoutError;
import java.util.concurrent.atomic.AtomicInteger;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

class PollingTest {

    // ============================================================================
    // calculateBackoffDelay tests
    // ============================================================================

    @Nested
    @DisplayName("calculateBackoffDelay")
    class CalculateBackoffDelayTests {

        @Nested
        @DisplayName("exponential backoff calculation")
        class ExponentialBackoffTests {

            @Test
            @DisplayName("should return initialDelayMs for attempt 0")
            void shouldReturnInitialDelayForAttemptZero() {
                // With random = 0.5, jitter factor is 0 (neutral)
                // We can't control Math.random, so we use jitterFraction = 0
                int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0);
                assertEquals(1000, delay);
            }

            @Test
            @DisplayName("should double delay for each attempt (no jitter)")
            void shouldDoubleDelayForEachAttempt() {
                assertEquals(1000, Polling.calculateBackoffDelay(0, 1000, 30000, 0));
                assertEquals(2000, Polling.calculateBackoffDelay(1, 1000, 30000, 0));
                assertEquals(4000, Polling.calculateBackoffDelay(2, 1000, 30000, 0));
                assertEquals(8000, Polling.calculateBackoffDelay(3, 1000, 30000, 0));
                assertEquals(16000, Polling.calculateBackoffDelay(4, 1000, 30000, 0));
            }

            @Test
            @DisplayName("should cap delay at maxDelayMs")
            void shouldCapDelayAtMaxDelayMs() {
                // 2^10 * 1000 = 1024000, but should be capped at 30000
                int delay = Polling.calculateBackoffDelay(10, 1000, 30000, 0);
                assertEquals(30000, delay);
            }

            @Test
            @DisplayName("should respect different initialDelayMs")
            void shouldRespectDifferentInitialDelayMs() {
                assertEquals(500, Polling.calculateBackoffDelay(0, 500, 30000, 0));
                assertEquals(1000, Polling.calculateBackoffDelay(1, 500, 30000, 0));
                assertEquals(2000, Polling.calculateBackoffDelay(2, 500, 30000, 0));
            }
        }

        @Nested
        @DisplayName("jitter application")
        class JitterTests {

            @Test
            @DisplayName("should apply jitter within expected range")
            void shouldApplyJitterWithinRange() {
                // Run multiple times to test jitter is applied
                int minSeen = Integer.MAX_VALUE;
                int maxSeen = Integer.MIN_VALUE;

                for (int i = 0; i < 100; i++) {
                    int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0.25);
                    minSeen = Math.min(minSeen, delay);
                    maxSeen = Math.max(maxSeen, delay);
                }

                // With 25% jitter, delays should be between 750 and 1250
                assertTrue(minSeen >= 750, "Min delay should be >= 750, was: " + minSeen);
                assertTrue(maxSeen <= 1250, "Max delay should be <= 1250, was: " + maxSeen);
            }

            @Test
            @DisplayName("should handle zero jitter fraction")
            void shouldHandleZeroJitterFraction() {
                int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0);
                assertEquals(1000, delay); // No jitter applied
            }

            @Test
            @DisplayName("should handle larger jitter fractions")
            void shouldHandleLargerJitterFractions() {
                // Run multiple times to test larger jitter
                int minSeen = Integer.MAX_VALUE;
                int maxSeen = Integer.MIN_VALUE;

                for (int i = 0; i < 100; i++) {
                    int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0.5);
                    minSeen = Math.min(minSeen, delay);
                    maxSeen = Math.max(maxSeen, delay);
                }

                // With 50% jitter, delays should be between 500 and 1500
                assertTrue(minSeen >= 500, "Min delay should be >= 500, was: " + minSeen);
                assertTrue(maxSeen <= 1500, "Max delay should be <= 1500, was: " + maxSeen);
            }
        }

        @Nested
        @DisplayName("edge cases")
        class EdgeCaseTests {

            @Test
            @DisplayName("should return integer value")
            void shouldReturnIntegerValue() {
                int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0.25);
                // Just verify it's a valid integer (no exception)
                assertTrue(delay > 0);
            }

            @Test
            @DisplayName("should handle very small initial delays")
            void shouldHandleVerySmallInitialDelays() {
                int delay = Polling.calculateBackoffDelay(0, 10, 30000, 0);
                assertEquals(10, delay);
            }

            @Test
            @DisplayName("should handle maxDelay smaller than initial delay")
            void shouldHandleMaxDelaySmallerThanInitialDelay() {
                int delay = Polling.calculateBackoffDelay(0, 1000, 500, 0);
                assertEquals(500, delay);
            }
        }
    }

    // ============================================================================
    // pollUntilDone tests
    // ============================================================================

    @Nested
    @DisplayName("pollUntilDone")
    class PollUntilDoneTests {

        @Nested
        @DisplayName("basic polling behavior")
        class BasicPollingTests {

            @Test
            @DisplayName("should return immediately when isTerminal returns true on first call")
            void shouldReturnImmediatelyWhenTerminalOnFirstCall() {
                AtomicInteger callCount = new AtomicInteger(0);

                TestResult result = Polling.pollUntilDone(
                        () -> {
                            callCount.incrementAndGet();
                            return new TestResult("DONE", 42);
                        },
                        r -> true,
                        PollingOptions.defaults());

                assertEquals("DONE", result.status);
                assertEquals(42, result.value);
                assertEquals(1, callCount.get());
            }

            @Test
            @DisplayName("should poll until isTerminal returns true")
            void shouldPollUntilTerminal() {
                AtomicInteger callCount = new AtomicInteger(0);

                TestResult result = Polling.pollUntilDone(
                        () -> {
                            int count = callCount.incrementAndGet();
                            return new TestResult(count >= 3 ? "DONE" : "PROCESSING", count);
                        },
                        r -> r.status.equals("DONE"),
                        PollingOptions.builder()
                                .initialDelayMs(1)
                                .maxWaitMs(10000)
                                .jitterFraction(0)
                                .build());

                assertEquals(3, callCount.get());
                assertEquals("DONE", result.status);
                assertEquals(3, result.value);
            }

            @Test
            @DisplayName("should pass result to isTerminal function")
            void shouldPassResultToIsTerminal() {
                TestResult expectedResult = new TestResult("DONE", 123);
                AtomicInteger terminalCallCount = new AtomicInteger(0);

                Polling.pollUntilDone(
                        () -> expectedResult,
                        r -> {
                            terminalCallCount.incrementAndGet();
                            assertEquals(expectedResult.status, r.status);
                            assertEquals(expectedResult.value, r.value);
                            return true;
                        },
                        PollingOptions.defaults());

                assertEquals(1, terminalCallCount.get());
            }
        }

        @Nested
        @DisplayName("timeout behavior")
        class TimeoutTests {

            @Test
            @DisplayName("should throw PollingTimeoutError when maxWaitMs is set and exceeded")
            void shouldThrowTimeoutError() {
                assertThrows(PollingTimeoutError.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .maxWaitMs(50)
                                    .initialDelayMs(10)
                                    .jitterFraction(0)
                                    .build());
                });
            }

            @Test
            @DisplayName("should include elapsed time in timeout error")
            void shouldIncludeElapsedTimeInError() {
                try {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .maxWaitMs(50)
                                    .initialDelayMs(10)
                                    .jitterFraction(0)
                                    .build());
                    fail("Expected PollingTimeoutError");
                } catch (PollingTimeoutError e) {
                    assertEquals(50, e.getMaxWaitMs());
                    assertTrue(e.getElapsedMs() >= 50, "Elapsed should be >= 50, was: " + e.getElapsedMs());
                }
            }

            @Test
            @DisplayName("should respect maxWaitMs option")
            void shouldRespectMaxWaitMs() {
                long startTime = System.currentTimeMillis();

                assertThrows(PollingTimeoutError.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .maxWaitMs(100)
                                    .initialDelayMs(10)
                                    .jitterFraction(0)
                                    .build());
                });

                long elapsed = System.currentTimeMillis() - startTime;
                assertTrue(elapsed >= 100, "Should have waited at least 100ms, waited: " + elapsed);
                assertTrue(elapsed < 500, "Should not have waited too long, waited: " + elapsed);
            }

            @Test
            @DisplayName("should poll indefinitely when maxWaitMs is not set")
            void shouldPollIndefinitelyWhenNoTimeout() {
                AtomicInteger callCount = new AtomicInteger(0);

                // Poll with no timeout - should complete when terminal without timeout error
                TestResult result = Polling.pollUntilDone(
                        () -> {
                            int count = callCount.incrementAndGet();
                            return new TestResult(count >= 3 ? "DONE" : "PROCESSING", count);
                        },
                        r -> r.status.equals("DONE"),
                        PollingOptions.builder()
                                .initialDelayMs(1)
                                .jitterFraction(0)
                                .build());  // No maxWaitMs set

                assertEquals(3, callCount.get());
                assertEquals("DONE", result.status);
            }
        }

        @Nested
        @DisplayName("error handling")
        class ErrorHandlingTests {

            @Test
            @DisplayName("should propagate errors from retrieve function")
            void shouldPropagateRetrieveErrors() {
                RuntimeException expected = new RuntimeException("API Error");

                RuntimeException thrown = assertThrows(RuntimeException.class, () -> {
                    Polling.pollUntilDone(
                            () -> {
                                throw expected;
                            },
                            r -> true,
                            PollingOptions.defaults());
                });

                assertEquals("API Error", thrown.getMessage());
            }

            @Test
            @DisplayName("should propagate errors from isTerminal function")
            void shouldPropagateIsTerminalErrors() {
                RuntimeException expected = new RuntimeException("isTerminal Error");

                RuntimeException thrown = assertThrows(RuntimeException.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("DONE", 0),
                            r -> {
                                throw expected;
                            },
                            PollingOptions.defaults());
                });

                assertEquals("isTerminal Error", thrown.getMessage());
            }
        }
    }

    // ============================================================================
    // PollingTimeoutError tests
    // ============================================================================

    @Nested
    @DisplayName("PollingTimeoutError")
    class PollingTimeoutErrorTests {

        @Test
        @DisplayName("should have correct message")
        void shouldHaveCorrectMessage() {
            PollingTimeoutError error = new PollingTimeoutError("Polling timed out", 1000, 5000);
            assertEquals("Polling timed out", error.getMessage());
        }

        @Test
        @DisplayName("should expose elapsedMs property")
        void shouldExposeElapsedMs() {
            PollingTimeoutError error = new PollingTimeoutError("test", 1234, 5000);
            assertEquals(1234, error.getElapsedMs());
        }

        @Test
        @DisplayName("should expose maxWaitMs property")
        void shouldExposeMaxWaitMs() {
            PollingTimeoutError error = new PollingTimeoutError("test", 1234, 5000);
            assertEquals(5000, error.getMaxWaitMs());
        }

        @Test
        @DisplayName("should be an instance of RuntimeException")
        void shouldBeRuntimeException() {
            PollingTimeoutError error = new PollingTimeoutError("test", 1000, 5000);
            assertTrue(error instanceof RuntimeException);
        }
    }

    // ============================================================================
    // PollingOptions tests
    // ============================================================================

    @Nested
    @DisplayName("PollingOptions")
    class PollingOptionsTests {

        @Test
        @DisplayName("should poll indefinitely by default (no timeout)")
        void shouldPollIndefinitelyByDefault() {
            PollingOptions options = PollingOptions.defaults();
            assertNull(options.getMaxWaitMs());
            assertFalse(options.hasTimeout());
            assertEquals(1_000, options.getInitialDelayMs());
            assertEquals(60_000, options.getMaxDelayMs());
            assertEquals(0.25, options.getJitterFraction());
            assertNull(options.getRequestOptions());
        }

        @Test
        @DisplayName("should allow custom values via builder")
        void shouldAllowCustomValues() {
            PollingOptions options = PollingOptions.builder()
                    .maxWaitMs(60000)
                    .initialDelayMs(500)
                    .maxDelayMs(10000)
                    .jitterFraction(0.5)
                    .build();

            assertEquals(Integer.valueOf(60000), options.getMaxWaitMs());
            assertTrue(options.hasTimeout());
            assertEquals(500, options.getInitialDelayMs());
            assertEquals(10000, options.getMaxDelayMs());
            assertEquals(0.5, options.getJitterFraction());
        }
    }

    // ============================================================================
    // Test helper class
    // ============================================================================

    private static class TestResult {
        final String status;
        final int value;

        TestResult(String status, int value) {
            this.status = status;
            this.value = value;
        }
    }
}
