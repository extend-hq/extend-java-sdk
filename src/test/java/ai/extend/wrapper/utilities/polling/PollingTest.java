/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.utilities.polling;

import static org.junit.jupiter.api.Assertions.*;

import ai.extend.wrapper.errors.PollingTimeoutError;
import java.util.concurrent.atomic.AtomicInteger;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

class PollingTest {

    // ============================================================================
    // calculateBackoffDelay tests
    // ============================================================================

    @Nested
    @DisplayName("calculateBackoffDelay")
    class CalculateBackoffDelayTests {

        @Nested
        @DisplayName("exponential backoff with default 2x multiplier")
        class ExponentialBackoffTests {

            @Test
            @DisplayName("should return initialDelayMs for attempt 0")
            void shouldReturnInitialDelayForAttemptZero() {
                // With random = 0.5, jitter factor is 0 (neutral)
                // We can't control Math.random, so we use jitterFraction = 0
                int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0);
                assertEquals(1000, delay);
            }

            @Test
            @DisplayName("should double delay for each attempt (no jitter)")
            void shouldDoubleDelayForEachAttempt() {
                assertEquals(1000, Polling.calculateBackoffDelay(0, 1000, 30000, 0));
                assertEquals(2000, Polling.calculateBackoffDelay(1, 1000, 30000, 0));
                assertEquals(4000, Polling.calculateBackoffDelay(2, 1000, 30000, 0));
                assertEquals(8000, Polling.calculateBackoffDelay(3, 1000, 30000, 0));
                assertEquals(16000, Polling.calculateBackoffDelay(4, 1000, 30000, 0));
            }

            @Test
            @DisplayName("should cap delay at maxDelayMs")
            void shouldCapDelayAtMaxDelayMs() {
                // 2^10 * 1000 = 1024000, but should be capped at 30000
                int delay = Polling.calculateBackoffDelay(10, 1000, 30000, 0);
                assertEquals(30000, delay);
            }

            @Test
            @DisplayName("should respect different initialDelayMs")
            void shouldRespectDifferentInitialDelayMs() {
                assertEquals(500, Polling.calculateBackoffDelay(0, 500, 30000, 0));
                assertEquals(1000, Polling.calculateBackoffDelay(1, 500, 30000, 0));
                assertEquals(2000, Polling.calculateBackoffDelay(2, 500, 30000, 0));
            }
        }

        @Nested
        @DisplayName("exponential backoff with custom multiplier")
        class CustomMultiplierTests {

            @Test
            @DisplayName("should use 1.5x multiplier when specified")
            void shouldUse15xMultiplier() {
                assertEquals(1000, Polling.calculateBackoffDelay(0, 1000, 30000, 0, 1.5));
                assertEquals(1500, Polling.calculateBackoffDelay(1, 1000, 30000, 0, 1.5));
                assertEquals(2250, Polling.calculateBackoffDelay(2, 1000, 30000, 0, 1.5));
                assertEquals(3375, Polling.calculateBackoffDelay(3, 1000, 30000, 0, 1.5));
            }

            @Test
            @DisplayName("should cap at maxDelayMs with 1.5x multiplier")
            void shouldCapAtMaxWithCustomMultiplier() {
                // 1.5^10 * 1000 â‰ˆ 57665, capped at 30000
                int delay = Polling.calculateBackoffDelay(10, 1000, 30000, 0, 1.5);
                assertEquals(30000, delay);
            }

            @Test
            @DisplayName("should work with 1x multiplier (constant delay)")
            void shouldWorkWith1xMultiplier() {
                assertEquals(1000, Polling.calculateBackoffDelay(0, 1000, 30000, 0, 1.0));
                assertEquals(1000, Polling.calculateBackoffDelay(5, 1000, 30000, 0, 1.0));
                assertEquals(1000, Polling.calculateBackoffDelay(10, 1000, 30000, 0, 1.0));
            }
        }

        @Nested
        @DisplayName("jitter application")
        class JitterTests {

            @Test
            @DisplayName("should apply jitter within expected range")
            void shouldApplyJitterWithinRange() {
                // Run multiple times to test jitter is applied
                int minSeen = Integer.MAX_VALUE;
                int maxSeen = Integer.MIN_VALUE;

                for (int i = 0; i < 100; i++) {
                    int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0.25);
                    minSeen = Math.min(minSeen, delay);
                    maxSeen = Math.max(maxSeen, delay);
                }

                // With 25% jitter, delays should be between 750 and 1250
                assertTrue(minSeen >= 750, "Min delay should be >= 750, was: " + minSeen);
                assertTrue(maxSeen <= 1250, "Max delay should be <= 1250, was: " + maxSeen);
            }

            @Test
            @DisplayName("should handle zero jitter fraction")
            void shouldHandleZeroJitterFraction() {
                int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0);
                assertEquals(1000, delay); // No jitter applied
            }

            @Test
            @DisplayName("should handle larger jitter fractions")
            void shouldHandleLargerJitterFractions() {
                // Run multiple times to test larger jitter
                int minSeen = Integer.MAX_VALUE;
                int maxSeen = Integer.MIN_VALUE;

                for (int i = 0; i < 100; i++) {
                    int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0.5);
                    minSeen = Math.min(minSeen, delay);
                    maxSeen = Math.max(maxSeen, delay);
                }

                // With 50% jitter, delays should be between 500 and 1500
                assertTrue(minSeen >= 500, "Min delay should be >= 500, was: " + minSeen);
                assertTrue(maxSeen <= 1500, "Max delay should be <= 1500, was: " + maxSeen);
            }
        }

        @Nested
        @DisplayName("edge cases")
        class EdgeCaseTests {

            @Test
            @DisplayName("should return integer value")
            void shouldReturnIntegerValue() {
                int delay = Polling.calculateBackoffDelay(0, 1000, 30000, 0.25);
                // Just verify it's a valid integer (no exception)
                assertTrue(delay > 0);
            }

            @Test
            @DisplayName("should handle very small initial delays")
            void shouldHandleVerySmallInitialDelays() {
                int delay = Polling.calculateBackoffDelay(0, 10, 30000, 0);
                assertEquals(10, delay);
            }

            @Test
            @DisplayName("should handle maxDelay smaller than initial delay")
            void shouldHandleMaxDelaySmallerThanInitialDelay() {
                int delay = Polling.calculateBackoffDelay(0, 1000, 500, 0);
                assertEquals(500, delay);
            }
        }
    }

    // ============================================================================
    // calculateHybridDelay tests
    // ============================================================================

    @Nested
    @DisplayName("calculateHybridDelay")
    class CalculateHybridDelayTests {

        @Nested
        @DisplayName("fast polling phase")
        class FastPollingPhaseTests {

            @Test
            @DisplayName("should return fastPollIntervalMs during fast phase")
            void shouldReturnFastPollIntervalDuringFastPhase() {
                assertEquals(1000, Polling.calculateHybridDelay(0, 30000, 1000, 1000, 30000, 1.15, 0));
                assertEquals(1000, Polling.calculateHybridDelay(10000, 30000, 1000, 1000, 30000, 1.15, 0));
                assertEquals(1000, Polling.calculateHybridDelay(29999, 30000, 1000, 1000, 30000, 1.15, 0));
            }

            @Test
            @DisplayName("should apply jitter during fast phase")
            void shouldApplyJitterDuringFastPhase() {
                int minSeen = Integer.MAX_VALUE;
                int maxSeen = Integer.MIN_VALUE;

                for (int i = 0; i < 100; i++) {
                    int delay = Polling.calculateHybridDelay(0, 30000, 1000, 1000, 30000, 1.15, 0.25);
                    minSeen = Math.min(minSeen, delay);
                    maxSeen = Math.max(maxSeen, delay);
                }

                // With 25% jitter, delays should be between 750 and 1250
                assertTrue(minSeen >= 750, "Min delay should be >= 750, was: " + minSeen);
                assertTrue(maxSeen <= 1250, "Max delay should be <= 1250, was: " + maxSeen);
            }

            @Test
            @DisplayName("should respect custom fastPollIntervalMs")
            void shouldRespectCustomFastPollIntervalMs() {
                int delay = Polling.calculateHybridDelay(0, 30000, 500, 1000, 30000, 1.15, 0);
                assertEquals(500, delay);
            }
        }

        @Nested
        @DisplayName("backoff phase")
        class BackoffPhaseTests {

            @Test
            @DisplayName("should switch to backoff after fastPollDurationMs")
            void shouldSwitchToBackoffAfterFastPhase() {
                // At exactly 30s, we're in backoff phase, attempt 0
                int delay = Polling.calculateHybridDelay(30000, 30000, 1000, 1000, 30000, 1.15, 0);
                assertEquals(1000, delay);
            }

            @Test
            @DisplayName("should increase delay during backoff phase with 1.15x multiplier")
            void shouldIncreaseDelayDuringBackoffPhase() {
                int delay30s = Polling.calculateHybridDelay(30000, 30000, 1000, 1000, 30000, 1.15, 0);
                assertEquals(1000, delay30s); // attempt 0

                int delay31s = Polling.calculateHybridDelay(31000, 30000, 1000, 1000, 30000, 1.15, 0);
                assertEquals(1150, delay31s); // attempt 1

                int delay32_15s = Polling.calculateHybridDelay(32150, 30000, 1000, 1000, 30000, 1.15, 0);
                assertEquals(1322, delay32_15s); // attempt 2
            }

            @Test
            @DisplayName("should cap delay at maxDelayMs")
            void shouldCapDelayAtMaxDelayMs() {
                // Far into backoff phase, delay should be capped
                int delay = Polling.calculateHybridDelay(300000, 30000, 1000, 1000, 30000, 1.15, 0);
                assertEquals(30000, delay);
            }

            @Test
            @DisplayName("should work with 2x multiplier")
            void shouldWorkWith2xMultiplier() {
                int delay30s = Polling.calculateHybridDelay(30000, 30000, 1000, 1000, 30000, 2.0, 0);
                assertEquals(1000, delay30s);

                int delay31s = Polling.calculateHybridDelay(31000, 30000, 1000, 1000, 30000, 2.0, 0);
                assertEquals(2000, delay31s);
            }

            @Test
            @DisplayName("should work with 1x multiplier (constant delay)")
            void shouldWorkWith1xMultiplier() {
                assertEquals(1000, Polling.calculateHybridDelay(30000, 30000, 1000, 1000, 30000, 1.0, 0));
                assertEquals(1000, Polling.calculateHybridDelay(60000, 30000, 1000, 1000, 30000, 1.0, 0));
                assertEquals(1000, Polling.calculateHybridDelay(120000, 30000, 1000, 1000, 30000, 1.0, 0));
            }
        }

        @Nested
        @DisplayName("edge cases")
        class EdgeCaseTests {

            @Test
            @DisplayName("should handle fastPollDurationMs = 0 (pure backoff)")
            void shouldHandleZeroFastPollDuration() {
                // Should immediately use backoff
                int delay = Polling.calculateHybridDelay(0, 0, 1000, 1000, 30000, 1.15, 0);
                assertEquals(1000, delay);
            }

            @Test
            @DisplayName("should handle very long elapsed times")
            void shouldHandleVeryLongElapsedTimes() {
                // 1 hour elapsed
                int delay = Polling.calculateHybridDelay(3600000, 30000, 1000, 1000, 30000, 1.15, 0);
                assertEquals(30000, delay); // Should be capped
            }

            @Test
            @DisplayName("should return positive delay for all inputs")
            void shouldReturnPositiveDelayForAllInputs() {
                for (int elapsed = 0; elapsed < 100000; elapsed += 5000) {
                    int delay = Polling.calculateHybridDelay(elapsed, 30000, 1000, 1000, 30000, 1.15, 0);
                    assertTrue(delay > 0, "Delay should be positive for elapsed=" + elapsed);
                }
            }
        }
    }

    // ============================================================================
    // pollUntilDone tests
    // ============================================================================

    @Nested
    @DisplayName("pollUntilDone")
    class PollUntilDoneTests {

        @Nested
        @DisplayName("basic polling behavior")
        class BasicPollingTests {

            @Test
            @DisplayName("should return immediately when isTerminal returns true on first call")
            void shouldReturnImmediatelyWhenTerminalOnFirstCall() {
                AtomicInteger callCount = new AtomicInteger(0);

                TestResult result = Polling.pollUntilDone(
                        () -> {
                            callCount.incrementAndGet();
                            return new TestResult("DONE", 42);
                        },
                        r -> true,
                        PollingOptions.defaults());

                assertEquals("DONE", result.status);
                assertEquals(42, result.value);
                assertEquals(1, callCount.get());
            }

            @Test
            @DisplayName("should poll until isTerminal returns true")
            void shouldPollUntilTerminal() {
                AtomicInteger callCount = new AtomicInteger(0);

                TestResult result = Polling.pollUntilDone(
                        () -> {
                            int count = callCount.incrementAndGet();
                            return new TestResult(count >= 3 ? "DONE" : "PROCESSING", count);
                        },
                        r -> r.status.equals("DONE"),
                        PollingOptions.builder()
                                .fastPollIntervalMs(1)
                                .maxWaitMs(10000)
                                .jitterFraction(0)
                                .build());

                assertEquals(3, callCount.get());
                assertEquals("DONE", result.status);
                assertEquals(3, result.value);
            }

            @Test
            @DisplayName("should pass result to isTerminal function")
            void shouldPassResultToIsTerminal() {
                TestResult expectedResult = new TestResult("DONE", 123);
                AtomicInteger terminalCallCount = new AtomicInteger(0);

                Polling.pollUntilDone(
                        () -> expectedResult,
                        r -> {
                            terminalCallCount.incrementAndGet();
                            assertEquals(expectedResult.status, r.status);
                            assertEquals(expectedResult.value, r.value);
                            return true;
                        },
                        PollingOptions.defaults());

                assertEquals(1, terminalCallCount.get());
            }
        }

        @Nested
        @DisplayName("hybrid polling strategy")
        class HybridPollingTests {

            @Test
            @DisplayName("should use fast polling during fast phase")
            void shouldUseFastPollingDuringFastPhase() {
                AtomicInteger callCount = new AtomicInteger(0);
                long[] callTimes = new long[4];

                TestResult result = Polling.pollUntilDone(
                        () -> {
                            int count = callCount.getAndIncrement();
                            if (count < 4) {
                                callTimes[count] = System.currentTimeMillis();
                            }
                            return new TestResult(count >= 3 ? "DONE" : "PROCESSING", count);
                        },
                        r -> r.status.equals("DONE"),
                        PollingOptions.builder()
                                .fastPollDurationMs(30000)  // Long fast phase
                                .fastPollIntervalMs(10)
                                .jitterFraction(0)
                                .maxWaitMs(5000)
                                .build());

                assertEquals(4, callCount.get());

                // All delays should be approximately equal during fast phase
                for (int i = 1; i < 4; i++) {
                    long delay = callTimes[i] - callTimes[i - 1];
                    assertTrue(delay >= 8, "Delay should be >= 8, was: " + delay);
                    assertTrue(delay < 50, "Delay should be < 50, was: " + delay);
                }
            }

            @Test
            @DisplayName("should support disabling fast phase with fastPollDurationMs=0")
            void shouldSupportDisablingFastPhase() {
                AtomicInteger callCount = new AtomicInteger(0);

                long startTime = System.currentTimeMillis();

                TestResult result = Polling.pollUntilDone(
                        () -> {
                            int count = callCount.incrementAndGet();
                            return new TestResult(count >= 2 ? "DONE" : "PROCESSING", count);
                        },
                        r -> r.status.equals("DONE"),
                        PollingOptions.builder()
                                .fastPollDurationMs(0)  // Pure backoff mode
                                .initialDelayMs(50)
                                .jitterFraction(0)
                                .maxWaitMs(5000)
                                .build());

                long elapsed = System.currentTimeMillis() - startTime;

                // Should have waited ~50ms (initial delay in backoff mode)
                assertTrue(elapsed >= 45, "Should have waited at least 45ms, waited: " + elapsed);
            }
        }

        @Nested
        @DisplayName("timeout behavior")
        class TimeoutTests {

            @Test
            @DisplayName("should throw PollingTimeoutError when maxWaitMs is set and exceeded")
            void shouldThrowTimeoutError() {
                assertThrows(PollingTimeoutError.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .maxWaitMs(50)
                                    .fastPollIntervalMs(10)
                                    .jitterFraction(0)
                                    .build());
                });
            }

            @Test
            @DisplayName("should include elapsed time in timeout error")
            void shouldIncludeElapsedTimeInError() {
                try {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .maxWaitMs(50)
                                    .fastPollIntervalMs(10)
                                    .jitterFraction(0)
                                    .build());
                    fail("Expected PollingTimeoutError");
                } catch (PollingTimeoutError e) {
                    assertEquals(50, e.getMaxWaitMs());
                    assertTrue(e.getElapsedMs() >= 50, "Elapsed should be >= 50, was: " + e.getElapsedMs());
                }
            }

            @Test
            @DisplayName("should respect maxWaitMs option")
            void shouldRespectMaxWaitMs() {
                long startTime = System.currentTimeMillis();

                assertThrows(PollingTimeoutError.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .maxWaitMs(100)
                                    .fastPollIntervalMs(10)
                                    .jitterFraction(0)
                                    .build());
                });

                long elapsed = System.currentTimeMillis() - startTime;
                assertTrue(elapsed >= 100, "Should have waited at least 100ms, waited: " + elapsed);
                assertTrue(elapsed < 500, "Should not have waited too long, waited: " + elapsed);
            }

            @Test
            @DisplayName("should poll indefinitely when maxWaitMs is not set")
            void shouldPollIndefinitelyWhenNoTimeout() {
                AtomicInteger callCount = new AtomicInteger(0);

                // Poll with no timeout - should complete when terminal without timeout error
                TestResult result = Polling.pollUntilDone(
                        () -> {
                            int count = callCount.incrementAndGet();
                            return new TestResult(count >= 3 ? "DONE" : "PROCESSING", count);
                        },
                        r -> r.status.equals("DONE"),
                        PollingOptions.builder()
                                .fastPollIntervalMs(1)
                                .jitterFraction(0)
                                .build());  // No maxWaitMs set

                assertEquals(3, callCount.get());
                assertEquals("DONE", result.status);
            }

            @Test
            @DisplayName("should timeout during fast polling phase")
            void shouldTimeoutDuringFastPhase() {
                assertThrows(PollingTimeoutError.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("PROCESSING", 0),
                            r -> false,
                            PollingOptions.builder()
                                    .fastPollDurationMs(30000)  // Long fast phase
                                    .fastPollIntervalMs(10)
                                    .maxWaitMs(50)  // Short timeout
                                    .jitterFraction(0)
                                    .build());
                });
            }
        }

        @Nested
        @DisplayName("error handling")
        class ErrorHandlingTests {

            @Test
            @DisplayName("should propagate errors from retrieve function")
            void shouldPropagateRetrieveErrors() {
                RuntimeException expected = new RuntimeException("API Error");

                RuntimeException thrown = assertThrows(RuntimeException.class, () -> {
                    Polling.pollUntilDone(
                            () -> {
                                throw expected;
                            },
                            r -> true,
                            PollingOptions.defaults());
                });

                assertEquals("API Error", thrown.getMessage());
            }

            @Test
            @DisplayName("should propagate errors from isTerminal function")
            void shouldPropagateIsTerminalErrors() {
                RuntimeException expected = new RuntimeException("isTerminal Error");

                RuntimeException thrown = assertThrows(RuntimeException.class, () -> {
                    Polling.pollUntilDone(
                            () -> new TestResult("DONE", 0),
                            r -> {
                                throw expected;
                            },
                            PollingOptions.defaults());
                });

                assertEquals("isTerminal Error", thrown.getMessage());
            }
        }
    }

    // ============================================================================
    // PollingTimeoutError tests
    // ============================================================================

    @Nested
    @DisplayName("PollingTimeoutError")
    class PollingTimeoutErrorTests {

        @Test
        @DisplayName("should have correct message")
        void shouldHaveCorrectMessage() {
            PollingTimeoutError error = new PollingTimeoutError("Polling timed out", 1000, 5000);
            assertEquals("Polling timed out", error.getMessage());
        }

        @Test
        @DisplayName("should expose elapsedMs property")
        void shouldExposeElapsedMs() {
            PollingTimeoutError error = new PollingTimeoutError("test", 1234, 5000);
            assertEquals(1234, error.getElapsedMs());
        }

        @Test
        @DisplayName("should expose maxWaitMs property")
        void shouldExposeMaxWaitMs() {
            PollingTimeoutError error = new PollingTimeoutError("test", 1234, 5000);
            assertEquals(5000, error.getMaxWaitMs());
        }

        @Test
        @DisplayName("should be an instance of RuntimeException")
        void shouldBeRuntimeException() {
            PollingTimeoutError error = new PollingTimeoutError("test", 1000, 5000);
            assertTrue(error instanceof RuntimeException);
        }
    }

    // ============================================================================
    // PollingOptions tests
    // ============================================================================

    @Nested
    @DisplayName("PollingOptions")
    class PollingOptionsTests {

        @Test
        @DisplayName("should have sensible defaults for hybrid polling")
        void shouldHaveSensibleDefaults() {
            PollingOptions options = PollingOptions.defaults();
            assertNull(options.getMaxWaitMs());
            assertFalse(options.hasTimeout());
            assertEquals(30_000, options.getFastPollDurationMs());
            assertEquals(1_000, options.getFastPollIntervalMs());
            assertEquals(1_000, options.getInitialDelayMs());
            assertEquals(30_000, options.getMaxDelayMs());
            assertEquals(1.15, options.getBackoffMultiplier());
            assertEquals(0.25, options.getJitterFraction());
            assertNull(options.getRequestOptions());
        }

        @Test
        @DisplayName("should allow custom values via builder")
        void shouldAllowCustomValues() {
            PollingOptions options = PollingOptions.builder()
                    .maxWaitMs(60000)
                    .fastPollDurationMs(15000)
                    .fastPollIntervalMs(500)
                    .initialDelayMs(500)
                    .maxDelayMs(10000)
                    .backoffMultiplier(2.0)
                    .jitterFraction(0.5)
                    .build();

            assertEquals(Integer.valueOf(60000), options.getMaxWaitMs());
            assertTrue(options.hasTimeout());
            assertEquals(15000, options.getFastPollDurationMs());
            assertEquals(500, options.getFastPollIntervalMs());
            assertEquals(500, options.getInitialDelayMs());
            assertEquals(10000, options.getMaxDelayMs());
            assertEquals(2.0, options.getBackoffMultiplier());
            assertEquals(0.5, options.getJitterFraction());
        }
    }

    // ============================================================================
    // Test helper class
    // ============================================================================

    private static class TestResult {
        final String status;
        final int value;

        TestResult(String status, int value) {
            this.status = status;
            this.value = value;
        }
    }
}
