/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.resources;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

import ai.extend.resources.workflowruns.WorkflowRunsClient;
import ai.extend.resources.workflowruns.types.WorkflowRunsCreateResponse;
import ai.extend.resources.workflowruns.types.WorkflowRunsRetrieveResponse;
import ai.extend.types.WorkflowRun;
import ai.extend.types.WorkflowRunStatus;
import ai.extend.wrapper.errors.PollingTimeoutError;
import ai.extend.wrapper.utilities.polling.PollingOptions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

/**
 * Tests for WorkflowRunsWrapper.createAndPoll method.
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class WorkflowRunsWrapperTest {

    @Mock
    private WorkflowRunsClient mockClient;

    private WorkflowRunsWrapper wrapper;

    @BeforeEach
    void setUp() {
        wrapper = new WorkflowRunsWrapper(mockClient);
    }

    @Nested
    @DisplayName("createAndPoll")
    class CreateAndPollTests {

        @Test
        @DisplayName("should create and poll until PROCESSED")
        void shouldCreateAndPollUntilProcessed() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun processingRun = mock(WorkflowRun.class);
            when(processingRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSING);
            WorkflowRunsRetrieveResponse processingResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processingResponse.getWorkflowRun()).thenReturn(processingRun);

            WorkflowRun processedRun = mock(WorkflowRun.class);
            when(processedRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSED);
            WorkflowRunsRetrieveResponse processedResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processedResponse.getWorkflowRun()).thenReturn(processedRun);

            when(mockClient.retrieve(eq(runId), any()))
                    .thenReturn(processingResponse)
                    .thenReturn(processedResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.PROCESSED, result.getWorkflowRun().getStatus());
            verify(mockClient, times(1)).create(any(), any());
            verify(mockClient, times(2)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should return immediately if already PROCESSED")
        void shouldReturnImmediatelyIfAlreadyProcessed() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun processedRun = mock(WorkflowRun.class);
            when(processedRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSED);
            WorkflowRunsRetrieveResponse processedResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processedResponse.getWorkflowRun()).thenReturn(processedRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(processedResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.PROCESSED, result.getWorkflowRun().getStatus());
            verify(mockClient, times(1)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should handle FAILED status as terminal")
        void shouldHandleFailedAsTerminal() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun failedRun = mock(WorkflowRun.class);
            when(failedRun.getStatus()).thenReturn(WorkflowRunStatus.FAILED);
            WorkflowRunsRetrieveResponse failedResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(failedResponse.getWorkflowRun()).thenReturn(failedRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(failedResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.FAILED, result.getWorkflowRun().getStatus());
        }

        @Test
        @DisplayName("should handle CANCELLED status as terminal")
        void shouldHandleCancelledAsTerminal() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun cancelledRun = mock(WorkflowRun.class);
            when(cancelledRun.getStatus()).thenReturn(WorkflowRunStatus.CANCELLED);
            WorkflowRunsRetrieveResponse cancelledResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(cancelledResponse.getWorkflowRun()).thenReturn(cancelledRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(cancelledResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.CANCELLED, result.getWorkflowRun().getStatus());
        }

        @Test
        @DisplayName("should handle NEEDS_REVIEW status as terminal")
        void shouldHandleNeedsReviewAsTerminal() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun needsReviewRun = mock(WorkflowRun.class);
            when(needsReviewRun.getStatus()).thenReturn(WorkflowRunStatus.NEEDS_REVIEW);
            WorkflowRunsRetrieveResponse needsReviewResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(needsReviewResponse.getWorkflowRun()).thenReturn(needsReviewRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(needsReviewResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.NEEDS_REVIEW, result.getWorkflowRun().getStatus());
        }

        @Test
        @DisplayName("should handle REJECTED status as terminal")
        void shouldHandleRejectedAsTerminal() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun rejectedRun = mock(WorkflowRun.class);
            when(rejectedRun.getStatus()).thenReturn(WorkflowRunStatus.REJECTED);
            WorkflowRunsRetrieveResponse rejectedResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(rejectedResponse.getWorkflowRun()).thenReturn(rejectedRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(rejectedResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.REJECTED, result.getWorkflowRun().getStatus());
        }

        @Test
        @DisplayName("should continue polling during PENDING status")
        void shouldContinuePollingDuringPending() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun pendingRun = mock(WorkflowRun.class);
            when(pendingRun.getStatus()).thenReturn(WorkflowRunStatus.PENDING);
            WorkflowRunsRetrieveResponse pendingResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(pendingResponse.getWorkflowRun()).thenReturn(pendingRun);

            WorkflowRun processingRun = mock(WorkflowRun.class);
            when(processingRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSING);
            WorkflowRunsRetrieveResponse processingResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processingResponse.getWorkflowRun()).thenReturn(processingRun);

            WorkflowRun processedRun = mock(WorkflowRun.class);
            when(processedRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSED);
            WorkflowRunsRetrieveResponse processedResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processedResponse.getWorkflowRun()).thenReturn(processedRun);

            when(mockClient.retrieve(eq(runId), any()))
                    .thenReturn(pendingResponse)
                    .thenReturn(processingResponse)
                    .thenReturn(processedResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.PROCESSED, result.getWorkflowRun().getStatus());
            verify(mockClient, times(3)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should continue polling during CANCELLING status")
        void shouldContinuePollingDuringCancelling() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun cancellingRun = mock(WorkflowRun.class);
            when(cancellingRun.getStatus()).thenReturn(WorkflowRunStatus.CANCELLING);
            WorkflowRunsRetrieveResponse cancellingResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(cancellingResponse.getWorkflowRun()).thenReturn(cancellingRun);

            WorkflowRun cancelledRun = mock(WorkflowRun.class);
            when(cancelledRun.getStatus()).thenReturn(WorkflowRunStatus.CANCELLED);
            WorkflowRunsRetrieveResponse cancelledResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(cancelledResponse.getWorkflowRun()).thenReturn(cancelledRun);

            when(mockClient.retrieve(eq(runId), any()))
                    .thenReturn(cancellingResponse)
                    .thenReturn(cancelledResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(WorkflowRunStatus.CANCELLED, result.getWorkflowRun().getStatus());
            verify(mockClient, times(2)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should throw PollingTimeoutError when timeout exceeded")
        void shouldThrowTimeoutError() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun processingRun = mock(WorkflowRun.class);
            when(processingRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSING);
            WorkflowRunsRetrieveResponse processingResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processingResponse.getWorkflowRun()).thenReturn(processingRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(processingResponse);

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(10)
                    .maxWaitMs(50)
                    .jitterFraction(0)
                    .build();

            assertThrows(PollingTimeoutError.class, () -> {
                wrapper.createAndPoll(null, options);
            });
        }

        @Test
        @DisplayName("should complete with default options (polls indefinitely)")
        void shouldCompleteWithDefaultOptions() {
            String runId = "workflow_run_test123";

            WorkflowRun createRun = mock(WorkflowRun.class);
            when(createRun.getId()).thenReturn(runId);
            WorkflowRunsCreateResponse createResponse = mock(WorkflowRunsCreateResponse.class);
            when(createResponse.getWorkflowRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);

            WorkflowRun processedRun = mock(WorkflowRun.class);
            when(processedRun.getStatus()).thenReturn(WorkflowRunStatus.PROCESSED);
            WorkflowRunsRetrieveResponse processedResponse = mock(WorkflowRunsRetrieveResponse.class);
            when(processedResponse.getWorkflowRun()).thenReturn(processedRun);

            when(mockClient.retrieve(eq(runId), any())).thenReturn(processedResponse);

            // Should complete - polls indefinitely by default
            WorkflowRunsRetrieveResponse result = wrapper.createAndPoll(null);

            assertEquals(WorkflowRunStatus.PROCESSED, result.getWorkflowRun().getStatus());
        }
    }
}
