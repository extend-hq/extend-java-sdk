/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.resources;

import ai.extend.resources.extractruns.ExtractRunsClient;
import ai.extend.resources.extractruns.requests.ExtractRunsCreateRequest;
import ai.extend.resources.extractruns.types.ExtractRunsCreateResponse;
import ai.extend.resources.extractruns.types.ExtractRunsRetrieveResponse;
import ai.extend.types.ExtractRun;
import ai.extend.types.ProcessorRunStatus;
import ai.extend.wrapper.errors.PollingTimeoutError;
import ai.extend.wrapper.utilities.polling.PollingOptions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

/**
 * Tests for ExtractRunsWrapper.createAndPoll method.
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class ExtractRunsWrapperTest {

    @Mock
    private ExtractRunsClient mockClient;

    private ExtractRunsWrapper wrapper;

    @BeforeEach
    void setUp() {
        // Use the package-private constructor with the mock client
        wrapper = new ExtractRunsWrapper(mockClient);
    }

    // ============================================================================
    // createAndPoll tests
    // ============================================================================

    @Nested
    @DisplayName("createAndPoll")
    class CreateAndPollTests {

        @Test
        @DisplayName("should create and poll until PROCESSED")
        void shouldCreateAndPollUntilProcessed() {
            String runId = "extract_run_test123";
            
            // Set up create response
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            // Set up retrieve responses - processing then processed
            ExtractRun processingRun = mock(ExtractRun.class);
            when(processingRun.getStatus()).thenReturn(ProcessorRunStatus.PROCESSING);
            ExtractRunsRetrieveResponse processingResponse = mock(ExtractRunsRetrieveResponse.class);
            when(processingResponse.getExtractRun()).thenReturn(processingRun);
            
            ExtractRun processedRun = mock(ExtractRun.class);
            when(processedRun.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);
            ExtractRunsRetrieveResponse processedResponse = mock(ExtractRunsRetrieveResponse.class);
            when(processedResponse.getExtractRun()).thenReturn(processedRun);
            
            when(mockClient.retrieve(eq(runId), any()))
                .thenReturn(processingResponse)
                .thenReturn(processedResponse);

            PollingOptions options = PollingOptions.builder()
                .initialDelayMs(1)
                .maxWaitMs(10000)
                .jitterFraction(0)
                .build();

            ExtractRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getExtractRun().getStatus());
            verify(mockClient, times(1)).create(any(), any());
            verify(mockClient, times(2)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should return immediately if already PROCESSED on first retrieve")
        void shouldReturnImmediatelyIfAlreadyProcessed() {
            String runId = "extract_run_test123";
            
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            ExtractRun processedRun = mock(ExtractRun.class);
            when(processedRun.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);
            ExtractRunsRetrieveResponse processedResponse = mock(ExtractRunsRetrieveResponse.class);
            when(processedResponse.getExtractRun()).thenReturn(processedRun);
            
            when(mockClient.retrieve(eq(runId), any())).thenReturn(processedResponse);

            PollingOptions options = PollingOptions.builder()
                .initialDelayMs(1)
                .maxWaitMs(10000)
                .jitterFraction(0)
                .build();

            ExtractRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getExtractRun().getStatus());
            verify(mockClient, times(1)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should handle FAILED status as terminal")
        void shouldHandleFailedAsTerminal() {
            String runId = "extract_run_test123";
            
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            ExtractRun failedRun = mock(ExtractRun.class);
            when(failedRun.getStatus()).thenReturn(ProcessorRunStatus.FAILED);
            ExtractRunsRetrieveResponse failedResponse = mock(ExtractRunsRetrieveResponse.class);
            when(failedResponse.getExtractRun()).thenReturn(failedRun);
            
            when(mockClient.retrieve(eq(runId), any())).thenReturn(failedResponse);

            PollingOptions options = PollingOptions.builder()
                .initialDelayMs(1)
                .maxWaitMs(10000)
                .jitterFraction(0)
                .build();

            ExtractRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.FAILED, result.getExtractRun().getStatus());
        }

        @Test
        @DisplayName("should handle CANCELLED status as terminal")
        void shouldHandleCancelledAsTerminal() {
            String runId = "extract_run_test123";
            
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            ExtractRun cancelledRun = mock(ExtractRun.class);
            when(cancelledRun.getStatus()).thenReturn(ProcessorRunStatus.CANCELLED);
            ExtractRunsRetrieveResponse cancelledResponse = mock(ExtractRunsRetrieveResponse.class);
            when(cancelledResponse.getExtractRun()).thenReturn(cancelledRun);
            
            when(mockClient.retrieve(eq(runId), any())).thenReturn(cancelledResponse);

            PollingOptions options = PollingOptions.builder()
                .initialDelayMs(1)
                .maxWaitMs(10000)
                .jitterFraction(0)
                .build();

            ExtractRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.CANCELLED, result.getExtractRun().getStatus());
        }

        @Test
        @DisplayName("should throw PollingTimeoutError when timeout exceeded")
        void shouldThrowTimeoutError() {
            String runId = "extract_run_test123";
            
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            ExtractRun processingRun = mock(ExtractRun.class);
            when(processingRun.getStatus()).thenReturn(ProcessorRunStatus.PROCESSING);
            ExtractRunsRetrieveResponse processingResponse = mock(ExtractRunsRetrieveResponse.class);
            when(processingResponse.getExtractRun()).thenReturn(processingRun);
            
            when(mockClient.retrieve(eq(runId), any())).thenReturn(processingResponse);

            PollingOptions options = PollingOptions.builder()
                .initialDelayMs(10)
                .maxWaitMs(50)
                .jitterFraction(0)
                .build();

            assertThrows(PollingTimeoutError.class, () -> {
                wrapper.createAndPoll(null, options);
            });
        }

        @Test
        @DisplayName("should continue polling while PROCESSING")
        void shouldContinuePollingWhileProcessing() {
            String runId = "extract_run_test123";
            
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            ExtractRun processingRun1 = mock(ExtractRun.class);
            when(processingRun1.getStatus()).thenReturn(ProcessorRunStatus.PROCESSING);
            ExtractRunsRetrieveResponse processingResponse1 = mock(ExtractRunsRetrieveResponse.class);
            when(processingResponse1.getExtractRun()).thenReturn(processingRun1);
            
            ExtractRun processingRun2 = mock(ExtractRun.class);
            when(processingRun2.getStatus()).thenReturn(ProcessorRunStatus.PROCESSING);
            ExtractRunsRetrieveResponse processingResponse2 = mock(ExtractRunsRetrieveResponse.class);
            when(processingResponse2.getExtractRun()).thenReturn(processingRun2);
            
            ExtractRun processedRun = mock(ExtractRun.class);
            when(processedRun.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);
            ExtractRunsRetrieveResponse processedResponse = mock(ExtractRunsRetrieveResponse.class);
            when(processedResponse.getExtractRun()).thenReturn(processedRun);
            
            when(mockClient.retrieve(eq(runId), any()))
                .thenReturn(processingResponse1)
                .thenReturn(processingResponse2)
                .thenReturn(processedResponse);

            PollingOptions options = PollingOptions.builder()
                .initialDelayMs(1)
                .maxWaitMs(10000)
                .jitterFraction(0)
                .build();

            ExtractRunsRetrieveResponse result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getExtractRun().getStatus());
            verify(mockClient, times(3)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should use default polling options when not specified")
        void shouldUseDefaultOptions() {
            String runId = "extract_run_test123";
            
            ExtractRun createRun = mock(ExtractRun.class);
            when(createRun.getId()).thenReturn(runId);
            ExtractRunsCreateResponse createResponse = mock(ExtractRunsCreateResponse.class);
            when(createResponse.getExtractRun()).thenReturn(createRun);
            when(mockClient.create(any(), any())).thenReturn(createResponse);
            
            ExtractRun processedRun = mock(ExtractRun.class);
            when(processedRun.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);
            ExtractRunsRetrieveResponse processedResponse = mock(ExtractRunsRetrieveResponse.class);
            when(processedResponse.getExtractRun()).thenReturn(processedRun);
            
            when(mockClient.retrieve(eq(runId), any())).thenReturn(processedResponse);

            // Should not throw - uses default options
            ExtractRunsRetrieveResponse result = wrapper.createAndPoll(null);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getExtractRun().getStatus());
        }
    }
}
