/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.resources;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

import ai.extend.core.ClientOptions;
import ai.extend.types.ClassifyRun;
import ai.extend.types.ProcessorRunStatus;
import ai.extend.wrapper.errors.PollingTimeoutError;
import ai.extend.wrapper.utilities.polling.PollingOptions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

/**
 * Tests for ClassifyRunsClient.createAndPoll method.
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class ClassifyRunsClientTest {

    private static final ClientOptions TEST_OPTIONS =
            ClientOptions.builder().addHeader("Authorization", "Bearer test").build();

    private ClassifyRunsClient wrapper;

    @BeforeEach
    void setUp() {
        wrapper = spy(new ClassifyRunsClient(TEST_OPTIONS));
    }

    @Nested
    @DisplayName("createAndPoll")
    class CreateAndPollTests {

        @Test
        @DisplayName("should create and poll until PROCESSED")
        void shouldCreateAndPollUntilProcessed() {
            String runId = "classify_run_test123";

            ClassifyRun createResponse = mock(ClassifyRun.class);
            when(createResponse.getId()).thenReturn(runId);
            doReturn(createResponse).when(wrapper).create(any(), any());

            ClassifyRun processingResponse = mock(ClassifyRun.class);
            when(processingResponse.getStatus()).thenReturn(ProcessorRunStatus.PROCESSING);

            ClassifyRun processedResponse = mock(ClassifyRun.class);
            when(processedResponse.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);

            doReturn(processingResponse)
                    .doReturn(processedResponse)
                    .when(wrapper)
                    .retrieve(eq(runId), any());

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            ClassifyRun result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getStatus());
            verify(wrapper, times(1)).create(any(), any());
            verify(wrapper, times(2)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should return immediately if already PROCESSED")
        void shouldReturnImmediatelyIfAlreadyProcessed() {
            String runId = "classify_run_test123";

            ClassifyRun createResponse = mock(ClassifyRun.class);
            when(createResponse.getId()).thenReturn(runId);
            doReturn(createResponse).when(wrapper).create(any(), any());

            ClassifyRun processedResponse = mock(ClassifyRun.class);
            when(processedResponse.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);

            doReturn(processedResponse).when(wrapper).retrieve(eq(runId), any());

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            ClassifyRun result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getStatus());
            verify(wrapper, times(1)).retrieve(eq(runId), any());
        }

        @Test
        @DisplayName("should handle FAILED status as terminal")
        void shouldHandleFailedAsTerminal() {
            String runId = "classify_run_test123";

            ClassifyRun createResponse = mock(ClassifyRun.class);
            when(createResponse.getId()).thenReturn(runId);
            doReturn(createResponse).when(wrapper).create(any(), any());

            ClassifyRun failedResponse = mock(ClassifyRun.class);
            when(failedResponse.getStatus()).thenReturn(ProcessorRunStatus.FAILED);

            doReturn(failedResponse).when(wrapper).retrieve(eq(runId), any());

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            ClassifyRun result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.FAILED, result.getStatus());
        }

        @Test
        @DisplayName("should handle CANCELLED status as terminal")
        void shouldHandleCancelledAsTerminal() {
            String runId = "classify_run_test123";

            ClassifyRun createResponse = mock(ClassifyRun.class);
            when(createResponse.getId()).thenReturn(runId);
            doReturn(createResponse).when(wrapper).create(any(), any());

            ClassifyRun cancelledResponse = mock(ClassifyRun.class);
            when(cancelledResponse.getStatus()).thenReturn(ProcessorRunStatus.CANCELLED);

            doReturn(cancelledResponse).when(wrapper).retrieve(eq(runId), any());

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(1)
                    .maxWaitMs(10000)
                    .jitterFraction(0)
                    .build();

            ClassifyRun result = wrapper.createAndPoll(null, options);

            assertEquals(ProcessorRunStatus.CANCELLED, result.getStatus());
        }

        @Test
        @DisplayName("should throw PollingTimeoutError when timeout exceeded")
        void shouldThrowTimeoutError() {
            String runId = "classify_run_test123";

            ClassifyRun createResponse = mock(ClassifyRun.class);
            when(createResponse.getId()).thenReturn(runId);
            doReturn(createResponse).when(wrapper).create(any(), any());

            ClassifyRun processingResponse = mock(ClassifyRun.class);
            when(processingResponse.getStatus()).thenReturn(ProcessorRunStatus.PROCESSING);

            doReturn(processingResponse).when(wrapper).retrieve(eq(runId), any());

            PollingOptions options = PollingOptions.builder()
                    .initialDelayMs(10)
                    .maxWaitMs(50)
                    .jitterFraction(0)
                    .build();

            assertThrows(PollingTimeoutError.class, () -> {
                wrapper.createAndPoll(null, options);
            });
        }

        @Test
        @DisplayName("should use default polling options when not specified")
        void shouldUseDefaultOptions() {
            String runId = "classify_run_test123";

            ClassifyRun createResponse = mock(ClassifyRun.class);
            when(createResponse.getId()).thenReturn(runId);
            doReturn(createResponse).when(wrapper).create(any(), any());

            ClassifyRun processedResponse = mock(ClassifyRun.class);
            when(processedResponse.getStatus()).thenReturn(ProcessorRunStatus.PROCESSED);

            doReturn(processedResponse).when(wrapper).retrieve(eq(runId), any());

            ClassifyRun result = wrapper.createAndPoll(null);

            assertEquals(ProcessorRunStatus.PROCESSED, result.getStatus());
        }
    }
}
