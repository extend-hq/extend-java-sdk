/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.webhooks;

import ai.extend.wrapper.errors.SignedUrlNotAllowedError;
import ai.extend.wrapper.errors.WebhookSignatureVerificationError;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

class WebhooksTest {

    private static final String SECRET = "wss_test_secret_123";
    private Webhooks webhooks;

    @BeforeEach
    void setUp() {
        webhooks = new Webhooks();
    }

    // ============================================================================
    // Test Helpers
    // ============================================================================

    private String createSignature(String body, String secret, long timestamp) {
        String message = "v0:" + timestamp + ":" + body;
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            mac.init(keySpec);
            byte[] hash = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create signature", e);
        }
    }

    private Map<String, String> createValidHeaders(String body, String secret) {
        return createValidHeaders(body, secret, System.currentTimeMillis() / 1000);
    }

    private Map<String, String> createValidHeaders(String body, String secret, long timestamp) {
        Map<String, String> headers = new HashMap<>();
        headers.put("x-extend-request-timestamp", String.valueOf(timestamp));
        headers.put("x-extend-request-signature", createSignature(body, secret, timestamp));
        return headers;
    }

    private String createWorkflowRunEventBody() {
        return "{" +
            "\"eventId\": \"evt_123\"," +
            "\"eventType\": \"workflow_run.completed\"," +
            "\"payload\": {" +
                "\"object\": \"workflow_run\"," +
                "\"id\": \"workflow_run_abc123\"," +
                "\"status\": \"PROCESSED\"" +
            "}" +
        "}";
    }

    private String createExtractRunEventBody() {
        return "{" +
            "\"eventId\": \"evt_456\"," +
            "\"eventType\": \"extract_run.processed\"," +
            "\"payload\": {" +
                "\"object\": \"extract_run\"," +
                "\"id\": \"extract_run_def456\"," +
                "\"status\": \"PROCESSED\"" +
            "}" +
        "}";
    }

    private String createSignedUrlEventBody() {
        return "{" +
            "\"eventId\": \"evt_789\"," +
            "\"eventType\": \"workflow_run.completed\"," +
            "\"payload\": {" +
                "\"object\": \"signed_data_url\"," +
                "\"data\": \"https://storage.example.com/signed-payload?token=abc123\"," +
                "\"id\": \"wr_xyz\"," +
                "\"metadata\": {\"env\": \"production\"}" +
            "}" +
        "}";
    }

    // ============================================================================
    // verifyAndParse tests
    // ============================================================================

    @Nested
    @DisplayName("verifyAndParse")
    class VerifyAndParseTests {

        @Nested
        @DisplayName("with valid signature")
        class ValidSignatureTests {

            @Test
            @DisplayName("should return event for normal payload")
            @SuppressWarnings("unchecked")
            void shouldReturnEventForNormalPayload() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                Map<String, Object> event = webhooks.verifyAndParse(body, headers, SECRET);

                assertEquals("evt_123", event.get("eventId"));
                assertEquals("workflow_run.completed", event.get("eventType"));
                assertNotNull(event.get("payload"));
            }

            @Test
            @DisplayName("should return event for extract_run.processed")
            @SuppressWarnings("unchecked")
            void shouldReturnEventForExtractRun() {
                String body = createExtractRunEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                Map<String, Object> event = webhooks.verifyAndParse(body, headers, SECRET);

                assertEquals("evt_456", event.get("eventId"));
                assertEquals("extract_run.processed", event.get("eventType"));
            }

            @Test
            @DisplayName("should throw SignedUrlNotAllowedError for signed URL without opt-in")
            void shouldThrowSignedUrlNotAllowedError() {
                String body = createSignedUrlEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                assertThrows(SignedUrlNotAllowedError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });
            }

            @Test
            @DisplayName("should throw SignedUrlNotAllowedError with helpful message")
            void shouldThrowWithHelpfulMessage() {
                String body = createSignedUrlEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                SignedUrlNotAllowedError error = assertThrows(SignedUrlNotAllowedError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                assertTrue(error.getMessage().contains("allowSignedUrl"));
            }

            @Test
            @DisplayName("should return WebhookEventWithSignedUrl with allowSignedUrl: true")
            void shouldReturnSignedUrlEventWhenAllowed() {
                String body = createSignedUrlEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                Object result = webhooks.verifyAndParse(body, headers, SECRET,
                    VerifyAndParseOptions.builder().allowSignedUrl(true).build());

                assertTrue(webhooks.isSignedUrlEvent(result));
                WebhookEventWithSignedUrl signedEvent = (WebhookEventWithSignedUrl) result;
                assertEquals("evt_789", signedEvent.getEventId());
                assertEquals("workflow_run.completed", signedEvent.getEventType());
                assertEquals("signed_data_url", signedEvent.getPayload().getObject());
                assertEquals("https://storage.example.com/signed-payload?token=abc123", signedEvent.getPayload().getData());
            }

            @Test
            @DisplayName("should return normal event with allowSignedUrl: true when not signed URL")
            @SuppressWarnings("unchecked")
            void shouldReturnNormalEventEvenWithAllowSignedUrl() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                Object result = webhooks.verifyAndParse(body, headers, SECRET,
                    VerifyAndParseOptions.builder().allowSignedUrl(true).build());

                assertFalse(webhooks.isSignedUrlEvent(result));
                Map<String, Object> event = (Map<String, Object>) result;
                assertEquals("workflow_run.completed", event.get("eventType"));
            }
        }

        @Nested
        @DisplayName("with invalid signature")
        class InvalidSignatureTests {

            @Test
            @DisplayName("should throw for wrong signature")
            void shouldThrowForWrongSignature() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = new HashMap<>();
                headers.put("x-extend-request-timestamp", String.valueOf(System.currentTimeMillis() / 1000));
                headers.put("x-extend-request-signature", "invalid_signature");

                assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });
            }

            @Test
            @DisplayName("should throw for missing timestamp header")
            void shouldThrowForMissingTimestamp() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = new HashMap<>();
                headers.put("x-extend-request-signature", "some_signature");

                WebhookSignatureVerificationError error = assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                assertTrue(error.getMessage().contains("timestamp"));
            }

            @Test
            @DisplayName("should throw for missing signature header")
            void shouldThrowForMissingSignature() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = new HashMap<>();
                headers.put("x-extend-request-timestamp", String.valueOf(System.currentTimeMillis() / 1000));

                WebhookSignatureVerificationError error = assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                assertTrue(error.getMessage().contains("signature"));
            }

            @Test
            @DisplayName("should throw for missing signing secret")
            void shouldThrowForMissingSecret() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                WebhookSignatureVerificationError error = assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, "");
                });

                assertTrue(error.getMessage().contains("secret"));
            }

            @Test
            @DisplayName("should throw for tampered body")
            void shouldThrowForTamperedBody() {
                String originalBody = createWorkflowRunEventBody();
                Map<String, String> headers = createValidHeaders(originalBody, SECRET);
                String tamperedBody = originalBody.replace("evt_123", "evt_tampered");

                assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(tamperedBody, headers, SECRET);
                });
            }

            @Test
            @DisplayName("should throw for wrong secret")
            void shouldThrowForWrongSecret() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = createValidHeaders(body, SECRET);

                assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, "wrong_secret");
                });
            }
        }

        @Nested
        @DisplayName("timestamp validation")
        class TimestampValidationTests {

            @Test
            @DisplayName("should reject requests older than maxAgeSeconds")
            void shouldRejectOldRequests() {
                String body = createWorkflowRunEventBody();
                long oldTimestamp = System.currentTimeMillis() / 1000 - 600; // 10 minutes ago
                Map<String, String> headers = createValidHeaders(body, SECRET, oldTimestamp);

                WebhookSignatureVerificationError error = assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                assertTrue(error.getMessage().contains("old"));
            }

            @Test
            @DisplayName("should accept requests within maxAgeSeconds")
            void shouldAcceptRecentRequests() {
                String body = createWorkflowRunEventBody();
                long recentTimestamp = System.currentTimeMillis() / 1000 - 60; // 1 minute ago
                Map<String, String> headers = createValidHeaders(body, SECRET, recentTimestamp);

                Map<String, Object> event = webhooks.verifyAndParse(body, headers, SECRET);
                assertEquals("evt_123", event.get("eventId"));
            }

            @Test
            @DisplayName("should allow custom maxAgeSeconds")
            void shouldAllowCustomMaxAge() {
                String body = createWorkflowRunEventBody();
                long oldTimestamp = System.currentTimeMillis() / 1000 - 600; // 10 minutes ago
                Map<String, String> headers = createValidHeaders(body, SECRET, oldTimestamp);

                // Should fail with default (300s)
                assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                // Should succeed with 900s
                @SuppressWarnings("unchecked")
                Map<String, Object> event = (Map<String, Object>) webhooks.verifyAndParse(body, headers, SECRET,
                    VerifyAndParseOptions.builder().maxAgeSeconds(900).build());
                assertEquals("evt_123", event.get("eventId"));
            }

            @Test
            @DisplayName("should disable timestamp validation when maxAgeSeconds is 0")
            void shouldDisableTimestampValidation() {
                String body = createWorkflowRunEventBody();
                long veryOldTimestamp = System.currentTimeMillis() / 1000 - 86400; // 1 day ago
                Map<String, String> headers = createValidHeaders(body, SECRET, veryOldTimestamp);

                @SuppressWarnings("unchecked")
                Map<String, Object> event = (Map<String, Object>) webhooks.verifyAndParse(body, headers, SECRET,
                    VerifyAndParseOptions.builder().maxAgeSeconds(0).build());
                assertEquals("evt_123", event.get("eventId"));
            }

            @Test
            @DisplayName("should reject timestamps too far in the future")
            void shouldRejectFutureTimestamps() {
                String body = createWorkflowRunEventBody();
                long futureTimestamp = System.currentTimeMillis() / 1000 + 120; // 2 minutes in future
                Map<String, String> headers = createValidHeaders(body, SECRET, futureTimestamp);

                WebhookSignatureVerificationError error = assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                assertTrue(error.getMessage().contains("future"));
            }

            @Test
            @DisplayName("should accept timestamps slightly in the future (clock skew)")
            void shouldAcceptSlightClockSkew() {
                String body = createWorkflowRunEventBody();
                long slightlyFutureTimestamp = System.currentTimeMillis() / 1000 + 30; // 30 seconds in future
                Map<String, String> headers = createValidHeaders(body, SECRET, slightlyFutureTimestamp);

                Map<String, Object> event = webhooks.verifyAndParse(body, headers, SECRET);
                assertEquals("evt_123", event.get("eventId"));
            }

            @Test
            @DisplayName("should throw for invalid timestamp format")
            void shouldThrowForInvalidTimestampFormat() {
                String body = createWorkflowRunEventBody();
                Map<String, String> headers = new HashMap<>();
                headers.put("x-extend-request-timestamp", "not-a-number");
                headers.put("x-extend-request-signature", createSignature(body, SECRET, 0));

                WebhookSignatureVerificationError error = assertThrows(WebhookSignatureVerificationError.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });

                assertTrue(error.getMessage().contains("timestamp"));
            }
        }

        @Nested
        @DisplayName("JSON parsing")
        class JsonParsingTests {

            @Test
            @DisplayName("should throw for invalid JSON body")
            void shouldThrowForInvalidJson() {
                String body = "not valid json";
                Map<String, String> headers = createValidHeaders(body, SECRET);

                assertThrows(RuntimeException.class, () -> {
                    webhooks.verifyAndParse(body, headers, SECRET);
                });
            }
        }

        @Nested
        @DisplayName("case-insensitive headers")
        class CaseInsensitiveHeadersTests {

            @Test
            @DisplayName("should work with lowercase header names")
            void shouldWorkWithLowercase() {
                String body = createWorkflowRunEventBody();
                long ts = System.currentTimeMillis() / 1000;
                Map<String, String> headers = new HashMap<>();
                headers.put("x-extend-request-timestamp", String.valueOf(ts));
                headers.put("x-extend-request-signature", createSignature(body, SECRET, ts));

                Map<String, Object> event = webhooks.verifyAndParse(body, headers, SECRET);
                assertEquals("evt_123", event.get("eventId"));
            }
        }
    }

    // ============================================================================
    // verify tests
    // ============================================================================

    @Nested
    @DisplayName("verify")
    class VerifyTests {

        @Test
        @DisplayName("should return true for valid signature")
        void shouldReturnTrueForValid() {
            String body = createWorkflowRunEventBody();
            Map<String, String> headers = createValidHeaders(body, SECRET);

            assertTrue(webhooks.verify(body, headers, SECRET));
        }

        @Test
        @DisplayName("should return false for invalid signature")
        void shouldReturnFalseForInvalid() {
            String body = createWorkflowRunEventBody();
            Map<String, String> headers = new HashMap<>();
            headers.put("x-extend-request-timestamp", String.valueOf(System.currentTimeMillis() / 1000));
            headers.put("x-extend-request-signature", "invalid");

            assertFalse(webhooks.verify(body, headers, SECRET));
        }

        @Test
        @DisplayName("should return false for missing headers")
        void shouldReturnFalseForMissingHeaders() {
            String body = createWorkflowRunEventBody();

            assertFalse(webhooks.verify(body, new HashMap<>(), SECRET));
        }

        @Test
        @DisplayName("should return false for expired timestamp")
        void shouldReturnFalseForExpired() {
            String body = createWorkflowRunEventBody();
            long oldTimestamp = System.currentTimeMillis() / 1000 - 600;
            Map<String, String> headers = createValidHeaders(body, SECRET, oldTimestamp);

            assertFalse(webhooks.verify(body, headers, SECRET));
        }

        @Test
        @DisplayName("should respect maxAgeSeconds option")
        void shouldRespectMaxAgeOption() {
            String body = createWorkflowRunEventBody();
            long oldTimestamp = System.currentTimeMillis() / 1000 - 600;
            Map<String, String> headers = createValidHeaders(body, SECRET, oldTimestamp);

            assertFalse(webhooks.verify(body, headers, SECRET));
            assertTrue(webhooks.verify(body, headers, SECRET, VerifyOptions.builder().maxAgeSeconds(900).build()));
        }
    }

    // ============================================================================
    // parse tests
    // ============================================================================

    @Nested
    @DisplayName("parse")
    class ParseTests {

        @Test
        @DisplayName("should parse normal webhook event")
        @SuppressWarnings("unchecked")
        void shouldParseNormalEvent() {
            String body = createWorkflowRunEventBody();

            Object result = webhooks.parse(body);
            Map<String, Object> event = (Map<String, Object>) result;

            assertEquals("evt_123", event.get("eventId"));
            assertEquals("workflow_run.completed", event.get("eventType"));
        }

        @Test
        @DisplayName("should parse signed URL webhook event")
        void shouldParseSignedUrlEvent() {
            String body = createSignedUrlEventBody();

            Object result = webhooks.parse(body);

            assertTrue(webhooks.isSignedUrlEvent(result));
            WebhookEventWithSignedUrl signedEvent = (WebhookEventWithSignedUrl) result;
            assertEquals("evt_789", signedEvent.getEventId());
        }

        @Test
        @DisplayName("should throw for invalid JSON")
        void shouldThrowForInvalidJson() {
            assertThrows(RuntimeException.class, () -> {
                webhooks.parse("not json");
            });
        }
    }

    // ============================================================================
    // isSignedUrlEvent tests
    // ============================================================================

    @Nested
    @DisplayName("isSignedUrlEvent")
    class IsSignedUrlEventTests {

        @Test
        @DisplayName("should return true for signed URL events")
        void shouldReturnTrueForSignedUrl() {
            String body = createSignedUrlEventBody();
            Object event = webhooks.parse(body);

            assertTrue(webhooks.isSignedUrlEvent(event));
        }

        @Test
        @DisplayName("should return false for normal events")
        void shouldReturnFalseForNormalEvents() {
            String body = createWorkflowRunEventBody();
            Object event = webhooks.parse(body);

            assertFalse(webhooks.isSignedUrlEvent(event));
        }
    }

    // ============================================================================
    // Error classes tests
    // ============================================================================

    @Nested
    @DisplayName("error classes")
    class ErrorClassesTests {

        @Test
        @DisplayName("WebhookSignatureVerificationError should have correct message")
        void webhookSignatureErrorShouldHaveMessage() {
            WebhookSignatureVerificationError error = new WebhookSignatureVerificationError("test message");
            assertEquals("test message", error.getMessage());
            assertTrue(error instanceof RuntimeException);
        }

        @Test
        @DisplayName("SignedUrlNotAllowedError should have correct message")
        void signedUrlErrorShouldHaveMessage() {
            SignedUrlNotAllowedError error = new SignedUrlNotAllowedError();
            assertTrue(error.getMessage().contains("allowSignedUrl"));
            assertTrue(error instanceof RuntimeException);
        }
    }
}
