/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.resources.evaluationsetitems;

import ai.extend.core.ClientOptions;
import ai.extend.core.ExtendClientApiException;
import ai.extend.core.ExtendClientException;
import ai.extend.core.ExtendClientHttpResponse;
import ai.extend.core.MediaTypes;
import ai.extend.core.ObjectMappers;
import ai.extend.core.QueryStringMapper;
import ai.extend.core.RequestOptions;
import ai.extend.errors.BadRequestError;
import ai.extend.errors.ForbiddenError;
import ai.extend.errors.InternalServerError;
import ai.extend.errors.NotFoundError;
import ai.extend.errors.PaymentRequiredError;
import ai.extend.errors.TooManyRequestsError;
import ai.extend.errors.UnauthorizedError;
import ai.extend.errors.UnprocessableEntityError;
import ai.extend.resources.evaluationsetitems.requests.EvaluationSetItemsCreateRequest;
import ai.extend.resources.evaluationsetitems.requests.EvaluationSetItemsListRequest;
import ai.extend.resources.evaluationsetitems.requests.EvaluationSetItemsUpdateRequest;
import ai.extend.resources.evaluationsetitems.types.EvaluationSetItemsCreateResponse;
import ai.extend.resources.evaluationsetitems.types.EvaluationSetItemsDeleteResponse;
import ai.extend.resources.evaluationsetitems.types.EvaluationSetItemsListResponse;
import ai.extend.types.ApiError;
import ai.extend.types.EvaluationSetItem;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawEvaluationSetItemsClient {
    protected final ClientOptions clientOptions;

    public AsyncRawEvaluationSetItemsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * List items in a specific evaluation set.
     * <p>Returns a summary of each evaluation set item. Use the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/evaluation/get-evaluation-set-item">Get Evaluation Set Item</a> endpoint to get the full details of an evaluation set item.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsListResponse>> list(String evaluationSetId) {
        return list(evaluationSetId, EvaluationSetItemsListRequest.builder().build());
    }

    /**
     * List items in a specific evaluation set.
     * <p>Returns a summary of each evaluation set item. Use the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/evaluation/get-evaluation-set-item">Get Evaluation Set Item</a> endpoint to get the full details of an evaluation set item.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsListResponse>> list(
            String evaluationSetId, RequestOptions requestOptions) {
        return list(evaluationSetId, EvaluationSetItemsListRequest.builder().build(), requestOptions);
    }

    /**
     * List items in a specific evaluation set.
     * <p>Returns a summary of each evaluation set item. Use the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/evaluation/get-evaluation-set-item">Get Evaluation Set Item</a> endpoint to get the full details of an evaluation set item.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsListResponse>> list(
            String evaluationSetId, EvaluationSetItemsListRequest request) {
        return list(evaluationSetId, request, null);
    }

    /**
     * List items in a specific evaluation set.
     * <p>Returns a summary of each evaluation set item. Use the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/evaluation/get-evaluation-set-item">Get Evaluation Set Item</a> endpoint to get the full details of an evaluation set item.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsListResponse>> list(
            String evaluationSetId, EvaluationSetItemsListRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_sets")
                .addPathSegment(evaluationSetId)
                .addPathSegments("items");
        if (request.getSortBy().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "sortBy", request.getSortBy().get(), false);
        }
        if (request.getSortDir().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "sortDir", request.getSortDir().get(), false);
        }
        if (request.getNextPageToken().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "nextPageToken", request.getNextPageToken().get(), false);
        }
        if (request.getMaxPageSize().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "maxPageSize", request.getMaxPageSize().get(), false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsListResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, EvaluationSetItemsListResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new PaymentRequiredError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 422:
                                future.completeExceptionally(new UnprocessableEntityError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given extractor, classifier, or splitter in Extend. This endpoint will create new evaluation set items in Extend, which will be used during an evaluation run.
     * <p><strong>Limit:</strong> You can create up to 100 items at a time.</p>
     * <p>Learn more about how to create evaluation set items in the <a href="https://docs.extend.ai/product/evaluation/overview">Evaluation Sets</a> product page.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsCreateResponse>> create(
            String evaluationSetId, EvaluationSetItemsCreateRequest request) {
        return create(evaluationSetId, request, null);
    }

    /**
     * Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given extractor, classifier, or splitter in Extend. This endpoint will create new evaluation set items in Extend, which will be used during an evaluation run.
     * <p><strong>Limit:</strong> You can create up to 100 items at a time.</p>
     * <p>Learn more about how to create evaluation set items in the <a href="https://docs.extend.ai/product/evaluation/overview">Evaluation Sets</a> product page.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsCreateResponse>> create(
            String evaluationSetId, EvaluationSetItemsCreateRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_sets")
                .addPathSegment(evaluationSetId)
                .addPathSegments("items");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsCreateResponse>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, EvaluationSetItemsCreateResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new PaymentRequiredError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 422:
                                future.completeExceptionally(new UnprocessableEntityError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get details of an evaluation set item.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItem>> retrieve(
            String evaluationSetId, String itemId) {
        return retrieve(evaluationSetId, itemId, null);
    }

    /**
     * Get details of an evaluation set item.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItem>> retrieve(
            String evaluationSetId, String itemId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_sets")
                .addPathSegment(evaluationSetId)
                .addPathSegments("items")
                .addPathSegment(itemId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItem>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, EvaluationSetItem.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new PaymentRequiredError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 422:
                                future.completeExceptionally(new UnprocessableEntityError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * If you need to change the expected output for a given evaluation set item, you can use this endpoint to update the item. This can be useful if you need to correct an error in the expected output or if the output of the extractor, classifier, or splitter has changed.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItem>> update(
            String evaluationSetId, String itemId, EvaluationSetItemsUpdateRequest request) {
        return update(evaluationSetId, itemId, request, null);
    }

    /**
     * If you need to change the expected output for a given evaluation set item, you can use this endpoint to update the item. This can be useful if you need to correct an error in the expected output or if the output of the extractor, classifier, or splitter has changed.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItem>> update(
            String evaluationSetId,
            String itemId,
            EvaluationSetItemsUpdateRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_sets")
                .addPathSegment(evaluationSetId)
                .addPathSegments("items")
                .addPathSegment(itemId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItem>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, EvaluationSetItem.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new PaymentRequiredError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 422:
                                future.completeExceptionally(new UnprocessableEntityError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Delete an evaluation set item.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsDeleteResponse>> delete(
            String evaluationSetId, String itemId) {
        return delete(evaluationSetId, itemId, null);
    }

    /**
     * Delete an evaluation set item.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsDeleteResponse>> delete(
            String evaluationSetId, String itemId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_sets")
                .addPathSegment(evaluationSetId)
                .addPathSegments("items")
                .addPathSegment(itemId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemsDeleteResponse>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, EvaluationSetItemsDeleteResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new PaymentRequiredError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 422:
                                future.completeExceptionally(new UnprocessableEntityError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
