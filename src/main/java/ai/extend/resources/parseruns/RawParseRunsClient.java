/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.resources.parseruns;

import ai.extend.core.ClientOptions;
import ai.extend.core.ExtendClientApiException;
import ai.extend.core.ExtendClientException;
import ai.extend.core.ExtendClientHttpResponse;
import ai.extend.core.MediaTypes;
import ai.extend.core.ObjectMappers;
import ai.extend.core.QueryStringMapper;
import ai.extend.core.RequestOptions;
import ai.extend.errors.BadRequestError;
import ai.extend.errors.ForbiddenError;
import ai.extend.errors.InternalServerError;
import ai.extend.errors.NotFoundError;
import ai.extend.errors.PaymentRequiredError;
import ai.extend.errors.TooManyRequestsError;
import ai.extend.errors.UnauthorizedError;
import ai.extend.errors.UnprocessableEntityError;
import ai.extend.resources.parseruns.requests.ParseRunsCreateRequest;
import ai.extend.resources.parseruns.requests.ParseRunsRetrieveRequest;
import ai.extend.resources.parseruns.types.ParseRunsDeleteResponse;
import ai.extend.types.ApiError;
import ai.extend.types.ParseRun;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class RawParseRunsClient {
    protected final ClientOptions clientOptions;

    public RawParseRunsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Parse files to get cleaned, chunked target content (e.g. markdown).
     * <p>The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>The request returns immediately with a <code>PROCESSING</code> status. Use webhooks or poll the Get Parse Run endpoint for results.</p>
     */
    public ExtendClientHttpResponse<ParseRun> create(ParseRunsCreateRequest request) {
        return create(request, null);
    }

    /**
     * Parse files to get cleaned, chunked target content (e.g. markdown).
     * <p>The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>The request returns immediately with a <code>PROCESSING</code> status. Use webhooks or poll the Get Parse Run endpoint for results.</p>
     */
    public ExtendClientHttpResponse<ParseRun> create(ParseRunsCreateRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("parse_runs");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            if (response.isSuccessful()) {
                return new ExtendClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ParseRun.class), response);
            }
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 401:
                        throw new UnauthorizedError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 402:
                        throw new PaymentRequiredError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 422:
                        throw new UnprocessableEntityError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 429:
                        throw new TooManyRequestsError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
            throw new ExtendClientApiException(
                    "Error with status code " + response.code(), response.code(), errorBody, response);
        } catch (IOException e) {
            throw new ExtendClientException("Network error executing HTTP request", e);
        }
    }

    /**
     * Retrieve the status and results of a parse run.
     * <p>Use this endpoint to get results for a parse run that has already completed, or to check on the status of a parse run initiated by the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/parse/create-parse-run">Create Parse Run</a> endpoint.</p>
     */
    public ExtendClientHttpResponse<ParseRun> retrieve(String id) {
        return retrieve(id, ParseRunsRetrieveRequest.builder().build());
    }

    /**
     * Retrieve the status and results of a parse run.
     * <p>Use this endpoint to get results for a parse run that has already completed, or to check on the status of a parse run initiated by the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/parse/create-parse-run">Create Parse Run</a> endpoint.</p>
     */
    public ExtendClientHttpResponse<ParseRun> retrieve(String id, RequestOptions requestOptions) {
        return retrieve(id, ParseRunsRetrieveRequest.builder().build(), requestOptions);
    }

    /**
     * Retrieve the status and results of a parse run.
     * <p>Use this endpoint to get results for a parse run that has already completed, or to check on the status of a parse run initiated by the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/parse/create-parse-run">Create Parse Run</a> endpoint.</p>
     */
    public ExtendClientHttpResponse<ParseRun> retrieve(String id, ParseRunsRetrieveRequest request) {
        return retrieve(id, request, null);
    }

    /**
     * Retrieve the status and results of a parse run.
     * <p>Use this endpoint to get results for a parse run that has already completed, or to check on the status of a parse run initiated by the <a href="https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/parse/create-parse-run">Create Parse Run</a> endpoint.</p>
     */
    public ExtendClientHttpResponse<ParseRun> retrieve(
            String id, ParseRunsRetrieveRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("parse_runs")
                .addPathSegment(id);
        if (request.getResponseType().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "responseType", request.getResponseType().get(), false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            if (response.isSuccessful()) {
                return new ExtendClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ParseRun.class), response);
            }
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 401:
                        throw new UnauthorizedError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 402:
                        throw new PaymentRequiredError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 422:
                        throw new UnprocessableEntityError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 429:
                        throw new TooManyRequestsError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
            throw new ExtendClientApiException(
                    "Error with status code " + response.code(), response.code(), errorBody, response);
        } catch (IOException e) {
            throw new ExtendClientException("Network error executing HTTP request", e);
        }
    }

    /**
     * Delete a parse run and all associated data from Extend. This operation is permanent and cannot be undone.
     * <p>This endpoint can be used if you'd like to manage data retention on your own rather than automated data retention policies. Or make one-off deletions for your downstream customers.</p>
     */
    public ExtendClientHttpResponse<ParseRunsDeleteResponse> delete(String id) {
        return delete(id, null);
    }

    /**
     * Delete a parse run and all associated data from Extend. This operation is permanent and cannot be undone.
     * <p>This endpoint can be used if you'd like to manage data retention on your own rather than automated data retention policies. Or make one-off deletions for your downstream customers.</p>
     */
    public ExtendClientHttpResponse<ParseRunsDeleteResponse> delete(String id, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("parse_runs")
                .addPathSegment(id);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            if (response.isSuccessful()) {
                return new ExtendClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ParseRunsDeleteResponse.class),
                        response);
            }
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 401:
                        throw new UnauthorizedError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 402:
                        throw new PaymentRequiredError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 422:
                        throw new UnprocessableEntityError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ApiError.class), response);
                    case 429:
                        throw new TooManyRequestsError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
            throw new ExtendClientApiException(
                    "Error with status code " + response.code(), response.code(), errorBody, response);
        } catch (IOException e) {
            throw new ExtendClientException("Network error executing HTTP request", e);
        }
    }
}
