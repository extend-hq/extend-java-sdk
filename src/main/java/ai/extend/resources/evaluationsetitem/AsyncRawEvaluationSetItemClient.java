/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.resources.evaluationsetitem;

import ai.extend.core.ClientOptions;
import ai.extend.core.ExtendClientApiException;
import ai.extend.core.ExtendClientException;
import ai.extend.core.ExtendClientHttpResponse;
import ai.extend.core.MediaTypes;
import ai.extend.core.ObjectMappers;
import ai.extend.core.QueryStringMapper;
import ai.extend.core.RequestOptions;
import ai.extend.errors.BadRequestError;
import ai.extend.errors.NotFoundError;
import ai.extend.errors.UnauthorizedError;
import ai.extend.resources.evaluationsetitem.requests.EvaluationSetItemCreateBatchRequest;
import ai.extend.resources.evaluationsetitem.requests.EvaluationSetItemCreateRequest;
import ai.extend.resources.evaluationsetitem.requests.EvaluationSetItemListRequest;
import ai.extend.resources.evaluationsetitem.requests.EvaluationSetItemUpdateRequest;
import ai.extend.resources.evaluationsetitem.types.EvaluationSetItemCreateBatchResponse;
import ai.extend.resources.evaluationsetitem.types.EvaluationSetItemCreateResponse;
import ai.extend.resources.evaluationsetitem.types.EvaluationSetItemListResponse;
import ai.extend.resources.evaluationsetitem.types.EvaluationSetItemUpdateResponse;
import ai.extend.types.Error;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawEvaluationSetItemClient {
    protected final ClientOptions clientOptions;

    public AsyncRawEvaluationSetItemClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * List all items in a specific evaluation set. Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend.
     * <p>This endpoint returns a paginated response. You can use the <code>nextPageToken</code> to fetch subsequent results.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemListResponse>> list(String id) {
        return list(id, EvaluationSetItemListRequest.builder().build());
    }

    /**
     * List all items in a specific evaluation set. Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend.
     * <p>This endpoint returns a paginated response. You can use the <code>nextPageToken</code> to fetch subsequent results.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemListResponse>> list(
            String id, EvaluationSetItemListRequest request) {
        return list(id, request, null);
    }

    /**
     * List all items in a specific evaluation set. Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend.
     * <p>This endpoint returns a paginated response. You can use the <code>nextPageToken</code> to fetch subsequent results.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemListResponse>> list(
            String id, EvaluationSetItemListRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_sets")
                .addPathSegment(id)
                .addPathSegments("items");
        if (request.getSortBy().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "sortBy", request.getSortBy().get(), false);
        }
        if (request.getSortDir().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "sortDir", request.getSortDir().get(), false);
        }
        if (request.getNextPageToken().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "nextPageToken", request.getNextPageToken().get(), false);
        }
        if (request.getMaxPageSize().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "maxPageSize", request.getMaxPageSize().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemListResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), EvaluationSetItemListResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend. This endpoint will create a new evaluation set item in Extend, which will be used during an evaluation run.
     * <p>Best Practices for Outputs in Evaluation Sets:</p>
     * <ul>
     * <li><strong>Configure First, Output Later</strong>
     * <ul>
     * <li>Always create and finalize your processor configuration before creating evaluation sets</li>
     * <li>Field IDs in outputs must match those defined in your processor configuration</li>
     * </ul>
     * </li>
     * <li><strong>Type Consistency</strong>
     * <ul>
     * <li>Ensure output types exactly match your processor configuration</li>
     * <li>For example, if a field is configured as &quot;currency&quot;, don't submit a simple number value</li>
     * </ul>
     * </li>
     * <li><strong>Field IDs</strong>
     * <ul>
     * <li>Use the exact field IDs from your processor configuration</li>
     * <li>Create your own semantic IDs instead in the configs for each field/type instead of using the generated ones</li>
     * </ul>
     * </li>
     * <li><strong>Value</strong>
     * <ul>
     * <li>Remember that all results are inside the value key of a result object, except the values within nested structures.</li>
     * </ul>
     * </li>
     * </ul>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemCreateResponse>> create(
            EvaluationSetItemCreateRequest request) {
        return create(request, null);
    }

    /**
     * Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend. This endpoint will create a new evaluation set item in Extend, which will be used during an evaluation run.
     * <p>Best Practices for Outputs in Evaluation Sets:</p>
     * <ul>
     * <li><strong>Configure First, Output Later</strong>
     * <ul>
     * <li>Always create and finalize your processor configuration before creating evaluation sets</li>
     * <li>Field IDs in outputs must match those defined in your processor configuration</li>
     * </ul>
     * </li>
     * <li><strong>Type Consistency</strong>
     * <ul>
     * <li>Ensure output types exactly match your processor configuration</li>
     * <li>For example, if a field is configured as &quot;currency&quot;, don't submit a simple number value</li>
     * </ul>
     * </li>
     * <li><strong>Field IDs</strong>
     * <ul>
     * <li>Use the exact field IDs from your processor configuration</li>
     * <li>Create your own semantic IDs instead in the configs for each field/type instead of using the generated ones</li>
     * </ul>
     * </li>
     * <li><strong>Value</strong>
     * <ul>
     * <li>Remember that all results are inside the value key of a result object, except the values within nested structures.</li>
     * </ul>
     * </li>
     * </ul>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemCreateResponse>> create(
            EvaluationSetItemCreateRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_set_items")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemCreateResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), EvaluationSetItemCreateResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * If you need to change the expected output for a given evaluation set item, you can use this endpoint to update the item. This can be useful if you need to correct an error in the expected output or if the output of the processor has changed.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemUpdateResponse>> update(
            String id, EvaluationSetItemUpdateRequest request) {
        return update(id, request, null);
    }

    /**
     * If you need to change the expected output for a given evaluation set item, you can use this endpoint to update the item. This can be useful if you need to correct an error in the expected output or if the output of the processor has changed.
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemUpdateResponse>> update(
            String id, EvaluationSetItemUpdateRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_set_items")
                .addPathSegment(id)
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemUpdateResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), EvaluationSetItemUpdateResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * If you have a large number of files that you need to add to an evaluation set, you can use this endpoint to create multiple evaluation set items at once. This can be useful if you have a large dataset that you need to evaluate the performance of a processor against.
     * <p>Note: you still need to create each File first using the file API.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemCreateBatchResponse>> createBatch(
            EvaluationSetItemCreateBatchRequest request) {
        return createBatch(request, null);
    }

    /**
     * If you have a large number of files that you need to add to an evaluation set, you can use this endpoint to create multiple evaluation set items at once. This can be useful if you have a large dataset that you need to evaluate the performance of a processor against.
     * <p>Note: you still need to create each File first using the file API.</p>
     */
    public CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemCreateBatchResponse>> createBatch(
            EvaluationSetItemCreateBatchRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("evaluation_set_items/bulk")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ExtendClientHttpResponse<EvaluationSetItemCreateBatchResponse>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new ExtendClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), EvaluationSetItemCreateBatchResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ExtendClientApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ExtendClientException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
