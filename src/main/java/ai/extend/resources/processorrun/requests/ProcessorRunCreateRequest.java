/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.resources.processorrun.requests;

import ai.extend.core.ObjectMappers;
import ai.extend.resources.processorrun.types.ProcessorRunCreateRequestConfig;
import ai.extend.types.ProcessorRunFileInput;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ProcessorRunCreateRequest.Builder.class)
public final class ProcessorRunCreateRequest {
    private final String processorId;

    private final Optional<String> version;

    private final Optional<ProcessorRunFileInput> file;

    private final Optional<String> rawText;

    private final Optional<Boolean> sync;

    private final Optional<Integer> priority;

    private final Optional<Map<String, Object>> metadata;

    private final Optional<ProcessorRunCreateRequestConfig> config;

    private final Map<String, Object> additionalProperties;

    private ProcessorRunCreateRequest(
            String processorId,
            Optional<String> version,
            Optional<ProcessorRunFileInput> file,
            Optional<String> rawText,
            Optional<Boolean> sync,
            Optional<Integer> priority,
            Optional<Map<String, Object>> metadata,
            Optional<ProcessorRunCreateRequestConfig> config,
            Map<String, Object> additionalProperties) {
        this.processorId = processorId;
        this.version = version;
        this.file = file;
        this.rawText = rawText;
        this.sync = sync;
        this.priority = priority;
        this.metadata = metadata;
        this.config = config;
        this.additionalProperties = additionalProperties;
    }

    @JsonProperty("processorId")
    public String getProcessorId() {
        return processorId;
    }

    /**
     * @return An optional version of the processor to use. When not supplied, the most recent published version of the processor will be used. Special values include:
     * <ul>
     * <li><code>&quot;latest&quot;</code> for the most recent published version. If there are no published versions, the draft version will be used.</li>
     * <li><code>&quot;draft&quot;</code> for the draft version.</li>
     * <li>Specific version numbers corresponding to versions your team has published, e.g. <code>&quot;1.0&quot;</code>, <code>&quot;2.2&quot;</code>, etc.</li>
     * </ul>
     */
    @JsonProperty("version")
    public Optional<String> getVersion() {
        return version;
    }

    /**
     * @return The file to be processed. One of <code>file</code> or <code>rawText</code> must be provided. Supported file types can be found <a href="/product/supported-file-types">here</a>.
     */
    @JsonProperty("file")
    public Optional<ProcessorRunFileInput> getFile() {
        return file;
    }

    /**
     * @return A raw string to be processed. Can be used in place of file when passing raw text data streams. One of <code>file</code> or <code>rawText</code> must be provided.
     */
    @JsonProperty("rawText")
    public Optional<String> getRawText() {
        return rawText;
    }

    /**
     * @return Whether to run the processor synchronously. When <code>true</code>, the request will wait for the processor run to complete and return the final results. When <code>false</code> (default), the request returns immediately with a <code>PROCESSING</code> status, and you can poll for completion or use webhooks. For production use cases, we recommending leaving sync off and building around an async integration for more resiliency, unless your use case is predictably fast (e.g. sub &lt; 30 seconds) run time or otherwise have integration constraints that require a synchronous API.
     * <p><strong>Timeout</strong>: Synchronous requests have a 5-minute timeout. If the processor run takes longer, it will continue processing asynchronously and you can retrieve the results via the GET endpoint.</p>
     */
    @JsonProperty("sync")
    public Optional<Boolean> getSync() {
        return sync;
    }

    /**
     * @return An optional value used to determine the relative order of ProcessorRuns when rate limiting is in effect. Lower values will be prioritized before higher values.
     */
    @JsonProperty("priority")
    public Optional<Integer> getPriority() {
        return priority;
    }

    /**
     * @return An optional object that can be passed in to identify the run of the document processor. It will be returned back to you in the response and webhooks.
     */
    @JsonProperty("metadata")
    public Optional<Map<String, Object>> getMetadata() {
        return metadata;
    }

    /**
     * @return The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.
     */
    @JsonProperty("config")
    public Optional<ProcessorRunCreateRequestConfig> getConfig() {
        return config;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ProcessorRunCreateRequest && equalTo((ProcessorRunCreateRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ProcessorRunCreateRequest other) {
        return processorId.equals(other.processorId)
                && version.equals(other.version)
                && file.equals(other.file)
                && rawText.equals(other.rawText)
                && sync.equals(other.sync)
                && priority.equals(other.priority)
                && metadata.equals(other.metadata)
                && config.equals(other.config);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.processorId,
                this.version,
                this.file,
                this.rawText,
                this.sync,
                this.priority,
                this.metadata,
                this.config);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static ProcessorIdStage builder() {
        return new Builder();
    }

    public interface ProcessorIdStage {
        _FinalStage processorId(@NotNull String processorId);

        Builder from(ProcessorRunCreateRequest other);
    }

    public interface _FinalStage {
        ProcessorRunCreateRequest build();

        /**
         * <p>An optional version of the processor to use. When not supplied, the most recent published version of the processor will be used. Special values include:</p>
         * <ul>
         * <li><code>&quot;latest&quot;</code> for the most recent published version. If there are no published versions, the draft version will be used.</li>
         * <li><code>&quot;draft&quot;</code> for the draft version.</li>
         * <li>Specific version numbers corresponding to versions your team has published, e.g. <code>&quot;1.0&quot;</code>, <code>&quot;2.2&quot;</code>, etc.</li>
         * </ul>
         */
        _FinalStage version(Optional<String> version);

        _FinalStage version(String version);

        /**
         * <p>The file to be processed. One of <code>file</code> or <code>rawText</code> must be provided. Supported file types can be found <a href="/product/supported-file-types">here</a>.</p>
         */
        _FinalStage file(Optional<ProcessorRunFileInput> file);

        _FinalStage file(ProcessorRunFileInput file);

        /**
         * <p>A raw string to be processed. Can be used in place of file when passing raw text data streams. One of <code>file</code> or <code>rawText</code> must be provided.</p>
         */
        _FinalStage rawText(Optional<String> rawText);

        _FinalStage rawText(String rawText);

        /**
         * <p>Whether to run the processor synchronously. When <code>true</code>, the request will wait for the processor run to complete and return the final results. When <code>false</code> (default), the request returns immediately with a <code>PROCESSING</code> status, and you can poll for completion or use webhooks. For production use cases, we recommending leaving sync off and building around an async integration for more resiliency, unless your use case is predictably fast (e.g. sub &lt; 30 seconds) run time or otherwise have integration constraints that require a synchronous API.</p>
         * <p><strong>Timeout</strong>: Synchronous requests have a 5-minute timeout. If the processor run takes longer, it will continue processing asynchronously and you can retrieve the results via the GET endpoint.</p>
         */
        _FinalStage sync(Optional<Boolean> sync);

        _FinalStage sync(Boolean sync);

        /**
         * <p>An optional value used to determine the relative order of ProcessorRuns when rate limiting is in effect. Lower values will be prioritized before higher values.</p>
         */
        _FinalStage priority(Optional<Integer> priority);

        _FinalStage priority(Integer priority);

        /**
         * <p>An optional object that can be passed in to identify the run of the document processor. It will be returned back to you in the response and webhooks.</p>
         */
        _FinalStage metadata(Optional<Map<String, Object>> metadata);

        _FinalStage metadata(Map<String, Object> metadata);

        /**
         * <p>The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.</p>
         */
        _FinalStage config(Optional<ProcessorRunCreateRequestConfig> config);

        _FinalStage config(ProcessorRunCreateRequestConfig config);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements ProcessorIdStage, _FinalStage {
        private String processorId;

        private Optional<ProcessorRunCreateRequestConfig> config = Optional.empty();

        private Optional<Map<String, Object>> metadata = Optional.empty();

        private Optional<Integer> priority = Optional.empty();

        private Optional<Boolean> sync = Optional.empty();

        private Optional<String> rawText = Optional.empty();

        private Optional<ProcessorRunFileInput> file = Optional.empty();

        private Optional<String> version = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(ProcessorRunCreateRequest other) {
            processorId(other.getProcessorId());
            version(other.getVersion());
            file(other.getFile());
            rawText(other.getRawText());
            sync(other.getSync());
            priority(other.getPriority());
            metadata(other.getMetadata());
            config(other.getConfig());
            return this;
        }

        @java.lang.Override
        @JsonSetter("processorId")
        public _FinalStage processorId(@NotNull String processorId) {
            this.processorId = Objects.requireNonNull(processorId, "processorId must not be null");
            return this;
        }

        /**
         * <p>The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage config(ProcessorRunCreateRequestConfig config) {
            this.config = Optional.ofNullable(config);
            return this;
        }

        /**
         * <p>The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "config", nulls = Nulls.SKIP)
        public _FinalStage config(Optional<ProcessorRunCreateRequestConfig> config) {
            this.config = config;
            return this;
        }

        /**
         * <p>An optional object that can be passed in to identify the run of the document processor. It will be returned back to you in the response and webhooks.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Map<String, Object> metadata) {
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * <p>An optional object that can be passed in to identify the run of the document processor. It will be returned back to you in the response and webhooks.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "metadata", nulls = Nulls.SKIP)
        public _FinalStage metadata(Optional<Map<String, Object>> metadata) {
            this.metadata = metadata;
            return this;
        }

        /**
         * <p>An optional value used to determine the relative order of ProcessorRuns when rate limiting is in effect. Lower values will be prioritized before higher values.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage priority(Integer priority) {
            this.priority = Optional.ofNullable(priority);
            return this;
        }

        /**
         * <p>An optional value used to determine the relative order of ProcessorRuns when rate limiting is in effect. Lower values will be prioritized before higher values.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "priority", nulls = Nulls.SKIP)
        public _FinalStage priority(Optional<Integer> priority) {
            this.priority = priority;
            return this;
        }

        /**
         * <p>Whether to run the processor synchronously. When <code>true</code>, the request will wait for the processor run to complete and return the final results. When <code>false</code> (default), the request returns immediately with a <code>PROCESSING</code> status, and you can poll for completion or use webhooks. For production use cases, we recommending leaving sync off and building around an async integration for more resiliency, unless your use case is predictably fast (e.g. sub &lt; 30 seconds) run time or otherwise have integration constraints that require a synchronous API.</p>
         * <p><strong>Timeout</strong>: Synchronous requests have a 5-minute timeout. If the processor run takes longer, it will continue processing asynchronously and you can retrieve the results via the GET endpoint.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage sync(Boolean sync) {
            this.sync = Optional.ofNullable(sync);
            return this;
        }

        /**
         * <p>Whether to run the processor synchronously. When <code>true</code>, the request will wait for the processor run to complete and return the final results. When <code>false</code> (default), the request returns immediately with a <code>PROCESSING</code> status, and you can poll for completion or use webhooks. For production use cases, we recommending leaving sync off and building around an async integration for more resiliency, unless your use case is predictably fast (e.g. sub &lt; 30 seconds) run time or otherwise have integration constraints that require a synchronous API.</p>
         * <p><strong>Timeout</strong>: Synchronous requests have a 5-minute timeout. If the processor run takes longer, it will continue processing asynchronously and you can retrieve the results via the GET endpoint.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "sync", nulls = Nulls.SKIP)
        public _FinalStage sync(Optional<Boolean> sync) {
            this.sync = sync;
            return this;
        }

        /**
         * <p>A raw string to be processed. Can be used in place of file when passing raw text data streams. One of <code>file</code> or <code>rawText</code> must be provided.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage rawText(String rawText) {
            this.rawText = Optional.ofNullable(rawText);
            return this;
        }

        /**
         * <p>A raw string to be processed. Can be used in place of file when passing raw text data streams. One of <code>file</code> or <code>rawText</code> must be provided.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "rawText", nulls = Nulls.SKIP)
        public _FinalStage rawText(Optional<String> rawText) {
            this.rawText = rawText;
            return this;
        }

        /**
         * <p>The file to be processed. One of <code>file</code> or <code>rawText</code> must be provided. Supported file types can be found <a href="/product/supported-file-types">here</a>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage file(ProcessorRunFileInput file) {
            this.file = Optional.ofNullable(file);
            return this;
        }

        /**
         * <p>The file to be processed. One of <code>file</code> or <code>rawText</code> must be provided. Supported file types can be found <a href="/product/supported-file-types">here</a>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "file", nulls = Nulls.SKIP)
        public _FinalStage file(Optional<ProcessorRunFileInput> file) {
            this.file = file;
            return this;
        }

        /**
         * <p>An optional version of the processor to use. When not supplied, the most recent published version of the processor will be used. Special values include:</p>
         * <ul>
         * <li><code>&quot;latest&quot;</code> for the most recent published version. If there are no published versions, the draft version will be used.</li>
         * <li><code>&quot;draft&quot;</code> for the draft version.</li>
         * <li>Specific version numbers corresponding to versions your team has published, e.g. <code>&quot;1.0&quot;</code>, <code>&quot;2.2&quot;</code>, etc.</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage version(String version) {
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * <p>An optional version of the processor to use. When not supplied, the most recent published version of the processor will be used. Special values include:</p>
         * <ul>
         * <li><code>&quot;latest&quot;</code> for the most recent published version. If there are no published versions, the draft version will be used.</li>
         * <li><code>&quot;draft&quot;</code> for the draft version.</li>
         * <li>Specific version numbers corresponding to versions your team has published, e.g. <code>&quot;1.0&quot;</code>, <code>&quot;2.2&quot;</code>, etc.</li>
         * </ul>
         */
        @java.lang.Override
        @JsonSetter(value = "version", nulls = Nulls.SKIP)
        public _FinalStage version(Optional<String> version) {
            this.version = version;
            return this;
        }

        @java.lang.Override
        public ProcessorRunCreateRequest build() {
            return new ProcessorRunCreateRequest(
                    processorId, version, file, rawText, sync, priority, metadata, config, additionalProperties);
        }
    }
}
