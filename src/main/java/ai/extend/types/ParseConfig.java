/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.types;

import ai.extend.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ParseConfig.Builder.class)
public final class ParseConfig {
    private final Optional<ParseConfigTarget> target;

    private final Optional<ParseConfigChunkingStrategy> chunkingStrategy;

    private final Optional<ParseConfigEngine> engine;

    private final Optional<ParseConfigBlockOptions> blockOptions;

    private final Optional<ParseConfigAdvancedOptions> advancedOptions;

    private final Map<String, Object> additionalProperties;

    private ParseConfig(
            Optional<ParseConfigTarget> target,
            Optional<ParseConfigChunkingStrategy> chunkingStrategy,
            Optional<ParseConfigEngine> engine,
            Optional<ParseConfigBlockOptions> blockOptions,
            Optional<ParseConfigAdvancedOptions> advancedOptions,
            Map<String, Object> additionalProperties) {
        this.target = target;
        this.chunkingStrategy = chunkingStrategy;
        this.engine = engine;
        this.blockOptions = blockOptions;
        this.advancedOptions = advancedOptions;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The target format for the parsed content.
     * <p>Supported values:</p>
     * <ul>
     * <li><code>markdown</code>: True markdown with logical reading order (headings, lists, tables, checkboxes). Best default for LLMs/RAG and enables section-based chunking.</li>
     * <li><code>spatial</code>: Layout/position-preserving text that uses markdown elements for block types but is not strictly markdown due to whitespace/tabs used to maintain placement. Only page-based chunking is supported.</li>
     * </ul>
     * <p>Guidance:</p>
     * <ul>
     * <li>Prefer <code>markdown</code> for most documents, multi-column reading order, and retrieval use cases</li>
     * <li>Prefer <code>spatial</code> for messy/scanned/handwritten or skewed documents, when you need near 1:1 layout fidelity, or for BOL-like logistics docs</li>
     * </ul>
     * <p>See &quot;Markdown vs Spatial&quot; in the Parse guide for details: /2025-04-21/developers/guides/parse#markdown-vs-spatial</p>
     */
    @JsonProperty("target")
    public Optional<ParseConfigTarget> getTarget() {
        return target;
    }

    /**
     * @return Strategy for dividing the document into chunks.
     */
    @JsonProperty("chunkingStrategy")
    public Optional<ParseConfigChunkingStrategy> getChunkingStrategy() {
        return chunkingStrategy;
    }

    /**
     * @return The parsing engine to use. Supported values:
     * <ul>
     * <li><code>parse_performance</code>: Full-featured parsing engine with highest accuracy (default)</li>
     * <li><code>parse_light</code>: Lightweight parsing engine optimized for speed. This does not have robust layout support and does not support markdown layout target.</li>
     * </ul>
     */
    @JsonProperty("engine")
    public Optional<ParseConfigEngine> getEngine() {
        return engine;
    }

    /**
     * @return Options for controlling how different block types are processed.
     */
    @JsonProperty("blockOptions")
    public Optional<ParseConfigBlockOptions> getBlockOptions() {
        return blockOptions;
    }

    @JsonProperty("advancedOptions")
    public Optional<ParseConfigAdvancedOptions> getAdvancedOptions() {
        return advancedOptions;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ParseConfig && equalTo((ParseConfig) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ParseConfig other) {
        return target.equals(other.target)
                && chunkingStrategy.equals(other.chunkingStrategy)
                && engine.equals(other.engine)
                && blockOptions.equals(other.blockOptions)
                && advancedOptions.equals(other.advancedOptions);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.target, this.chunkingStrategy, this.engine, this.blockOptions, this.advancedOptions);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<ParseConfigTarget> target = Optional.empty();

        private Optional<ParseConfigChunkingStrategy> chunkingStrategy = Optional.empty();

        private Optional<ParseConfigEngine> engine = Optional.empty();

        private Optional<ParseConfigBlockOptions> blockOptions = Optional.empty();

        private Optional<ParseConfigAdvancedOptions> advancedOptions = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ParseConfig other) {
            target(other.getTarget());
            chunkingStrategy(other.getChunkingStrategy());
            engine(other.getEngine());
            blockOptions(other.getBlockOptions());
            advancedOptions(other.getAdvancedOptions());
            return this;
        }

        /**
         * <p>The target format for the parsed content.</p>
         * <p>Supported values:</p>
         * <ul>
         * <li><code>markdown</code>: True markdown with logical reading order (headings, lists, tables, checkboxes). Best default for LLMs/RAG and enables section-based chunking.</li>
         * <li><code>spatial</code>: Layout/position-preserving text that uses markdown elements for block types but is not strictly markdown due to whitespace/tabs used to maintain placement. Only page-based chunking is supported.</li>
         * </ul>
         * <p>Guidance:</p>
         * <ul>
         * <li>Prefer <code>markdown</code> for most documents, multi-column reading order, and retrieval use cases</li>
         * <li>Prefer <code>spatial</code> for messy/scanned/handwritten or skewed documents, when you need near 1:1 layout fidelity, or for BOL-like logistics docs</li>
         * </ul>
         * <p>See &quot;Markdown vs Spatial&quot; in the Parse guide for details: /2025-04-21/developers/guides/parse#markdown-vs-spatial</p>
         */
        @JsonSetter(value = "target", nulls = Nulls.SKIP)
        public Builder target(Optional<ParseConfigTarget> target) {
            this.target = target;
            return this;
        }

        public Builder target(ParseConfigTarget target) {
            this.target = Optional.ofNullable(target);
            return this;
        }

        /**
         * <p>Strategy for dividing the document into chunks.</p>
         */
        @JsonSetter(value = "chunkingStrategy", nulls = Nulls.SKIP)
        public Builder chunkingStrategy(Optional<ParseConfigChunkingStrategy> chunkingStrategy) {
            this.chunkingStrategy = chunkingStrategy;
            return this;
        }

        public Builder chunkingStrategy(ParseConfigChunkingStrategy chunkingStrategy) {
            this.chunkingStrategy = Optional.ofNullable(chunkingStrategy);
            return this;
        }

        /**
         * <p>The parsing engine to use. Supported values:</p>
         * <ul>
         * <li><code>parse_performance</code>: Full-featured parsing engine with highest accuracy (default)</li>
         * <li><code>parse_light</code>: Lightweight parsing engine optimized for speed. This does not have robust layout support and does not support markdown layout target.</li>
         * </ul>
         */
        @JsonSetter(value = "engine", nulls = Nulls.SKIP)
        public Builder engine(Optional<ParseConfigEngine> engine) {
            this.engine = engine;
            return this;
        }

        public Builder engine(ParseConfigEngine engine) {
            this.engine = Optional.ofNullable(engine);
            return this;
        }

        /**
         * <p>Options for controlling how different block types are processed.</p>
         */
        @JsonSetter(value = "blockOptions", nulls = Nulls.SKIP)
        public Builder blockOptions(Optional<ParseConfigBlockOptions> blockOptions) {
            this.blockOptions = blockOptions;
            return this;
        }

        public Builder blockOptions(ParseConfigBlockOptions blockOptions) {
            this.blockOptions = Optional.ofNullable(blockOptions);
            return this;
        }

        @JsonSetter(value = "advancedOptions", nulls = Nulls.SKIP)
        public Builder advancedOptions(Optional<ParseConfigAdvancedOptions> advancedOptions) {
            this.advancedOptions = advancedOptions;
            return this;
        }

        public Builder advancedOptions(ParseConfigAdvancedOptions advancedOptions) {
            this.advancedOptions = Optional.ofNullable(advancedOptions);
            return this;
        }

        public ParseConfig build() {
            return new ParseConfig(
                    target, chunkingStrategy, engine, blockOptions, advancedOptions, additionalProperties);
        }
    }
}
