/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.types;

import ai.extend.core.Nullable;
import ai.extend.core.NullableNonemptyFilter;
import ai.extend.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = SplitRun.Builder.class)
public final class SplitRun {
    private final String id;

    private final Optional<SplitterSummary> splitter;

    private final Optional<SplitterVersionSummary> splitterVersion;

    private final ProcessorRunStatus status;

    private final Optional<SplitOutput> output;

    private final Optional<SplitOutput> initialOutput;

    private final Optional<SplitOutput> reviewedOutput;

    private final Optional<String> failureReason;

    private final Optional<String> failureMessage;

    private final Optional<Map<String, Object>> metadata;

    private final boolean reviewed;

    private final boolean edited;

    private final SplitConfig config;

    private final FileSummary file;

    private final Optional<String> parseRunId;

    private final String dashboardUrl;

    private final Optional<RunUsage> usage;

    private final OffsetDateTime createdAt;

    private final OffsetDateTime updatedAt;

    private final Map<String, Object> additionalProperties;

    private SplitRun(
            String id,
            Optional<SplitterSummary> splitter,
            Optional<SplitterVersionSummary> splitterVersion,
            ProcessorRunStatus status,
            Optional<SplitOutput> output,
            Optional<SplitOutput> initialOutput,
            Optional<SplitOutput> reviewedOutput,
            Optional<String> failureReason,
            Optional<String> failureMessage,
            Optional<Map<String, Object>> metadata,
            boolean reviewed,
            boolean edited,
            SplitConfig config,
            FileSummary file,
            Optional<String> parseRunId,
            String dashboardUrl,
            Optional<RunUsage> usage,
            OffsetDateTime createdAt,
            OffsetDateTime updatedAt,
            Map<String, Object> additionalProperties) {
        this.id = id;
        this.splitter = splitter;
        this.splitterVersion = splitterVersion;
        this.status = status;
        this.output = output;
        this.initialOutput = initialOutput;
        this.reviewedOutput = reviewedOutput;
        this.failureReason = failureReason;
        this.failureMessage = failureMessage;
        this.metadata = metadata;
        this.reviewed = reviewed;
        this.edited = edited;
        this.config = config;
        this.file = file;
        this.parseRunId = parseRunId;
        this.dashboardUrl = dashboardUrl;
        this.usage = usage;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The type of object. Will always be <code>&quot;split_run&quot;</code>.
     */
    @JsonProperty("object")
    public String getObject() {
        return "split_run";
    }

    /**
     * @return The unique identifier for this split run.
     * <p>Example: <code>&quot;splr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
     */
    @JsonProperty("id")
    public String getId() {
        return id;
    }

    /**
     * @return The splitter that was used for this run.
     * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
     */
    @JsonIgnore
    public Optional<SplitterSummary> getSplitter() {
        if (splitter == null) {
            return Optional.empty();
        }
        return splitter;
    }

    /**
     * @return The version of the splitter that was used for this run.
     * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
     */
    @JsonIgnore
    public Optional<SplitterVersionSummary> getSplitterVersion() {
        if (splitterVersion == null) {
            return Optional.empty();
        }
        return splitterVersion;
    }

    @JsonProperty("status")
    public ProcessorRunStatus getStatus() {
        return status;
    }

    /**
     * @return The final output, either reviewed or initial.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
     */
    @JsonIgnore
    public Optional<SplitOutput> getOutput() {
        if (output == null) {
            return Optional.empty();
        }
        return output;
    }

    /**
     * @return The initial output from the split run, before any review edits.
     * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
     */
    @JsonIgnore
    public Optional<SplitOutput> getInitialOutput() {
        if (initialOutput == null) {
            return Optional.empty();
        }
        return initialOutput;
    }

    /**
     * @return The output after human review.
     * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
     */
    @JsonIgnore
    public Optional<SplitOutput> getReviewedOutput() {
        if (reviewedOutput == null) {
            return Optional.empty();
        }
        return reviewedOutput;
    }

    /**
     * @return The reason for failure.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
     * <p>Possible values include:</p>
     * <ul>
     * <li><code>ABORTED</code> - The run was aborted by the user</li>
     * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
     * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
     * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
     * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
     * <li><code>PARSING_ERROR</code> - Failed to parse the splitting output</li>
     * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing</li>
     * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
     * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the splitter</li>
     * </ul>
     * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
     */
    @JsonIgnore
    public Optional<String> getFailureReason() {
        if (failureReason == null) {
            return Optional.empty();
        }
        return failureReason;
    }

    /**
     * @return A detailed message about the failure.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
     */
    @JsonIgnore
    public Optional<String> getFailureMessage() {
        if (failureMessage == null) {
            return Optional.empty();
        }
        return failureMessage;
    }

    /**
     * @return Any metadata that was provided when creating the split run.
     * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
     */
    @JsonIgnore
    public Optional<Map<String, Object>> getMetadata() {
        if (metadata == null) {
            return Optional.empty();
        }
        return metadata;
    }

    /**
     * @return Indicates whether the run has been reviewed by a human.
     */
    @JsonProperty("reviewed")
    public boolean getReviewed() {
        return reviewed;
    }

    /**
     * @return Indicates whether the run results have been edited during review.
     */
    @JsonProperty("edited")
    public boolean getEdited() {
        return edited;
    }

    /**
     * @return The configuration used for this split run.
     */
    @JsonProperty("config")
    public SplitConfig getConfig() {
        return config;
    }

    /**
     * @return The file that was processed.
     */
    @JsonProperty("file")
    public FileSummary getFile() {
        return file;
    }

    /**
     * @return The ID of the parse run that was used for this split run.
     * <p><strong>Availability:</strong> Present when a parse run was created.</p>
     */
    @JsonIgnore
    public Optional<String> getParseRunId() {
        if (parseRunId == null) {
            return Optional.empty();
        }
        return parseRunId;
    }

    /**
     * @return The URL to view the split run in the Extend dashboard.
     */
    @JsonProperty("dashboardUrl")
    public String getDashboardUrl() {
        return dashboardUrl;
    }

    /**
     * @return Usage credits consumed by this run.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
     */
    @JsonIgnore
    public Optional<RunUsage> getUsage() {
        if (usage == null) {
            return Optional.empty();
        }
        return usage;
    }

    @JsonProperty("createdAt")
    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    @JsonProperty("updatedAt")
    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("splitter")
    private Optional<SplitterSummary> _getSplitter() {
        return splitter;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("splitterVersion")
    private Optional<SplitterVersionSummary> _getSplitterVersion() {
        return splitterVersion;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("output")
    private Optional<SplitOutput> _getOutput() {
        return output;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("initialOutput")
    private Optional<SplitOutput> _getInitialOutput() {
        return initialOutput;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("reviewedOutput")
    private Optional<SplitOutput> _getReviewedOutput() {
        return reviewedOutput;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("failureReason")
    private Optional<String> _getFailureReason() {
        return failureReason;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("failureMessage")
    private Optional<String> _getFailureMessage() {
        return failureMessage;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("metadata")
    private Optional<Map<String, Object>> _getMetadata() {
        return metadata;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("parseRunId")
    private Optional<String> _getParseRunId() {
        return parseRunId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("usage")
    private Optional<RunUsage> _getUsage() {
        return usage;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof SplitRun && equalTo((SplitRun) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(SplitRun other) {
        return id.equals(other.id)
                && splitter.equals(other.splitter)
                && splitterVersion.equals(other.splitterVersion)
                && status.equals(other.status)
                && output.equals(other.output)
                && initialOutput.equals(other.initialOutput)
                && reviewedOutput.equals(other.reviewedOutput)
                && failureReason.equals(other.failureReason)
                && failureMessage.equals(other.failureMessage)
                && metadata.equals(other.metadata)
                && reviewed == other.reviewed
                && edited == other.edited
                && config.equals(other.config)
                && file.equals(other.file)
                && parseRunId.equals(other.parseRunId)
                && dashboardUrl.equals(other.dashboardUrl)
                && usage.equals(other.usage)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.id,
                this.splitter,
                this.splitterVersion,
                this.status,
                this.output,
                this.initialOutput,
                this.reviewedOutput,
                this.failureReason,
                this.failureMessage,
                this.metadata,
                this.reviewed,
                this.edited,
                this.config,
                this.file,
                this.parseRunId,
                this.dashboardUrl,
                this.usage,
                this.createdAt,
                this.updatedAt);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static IdStage builder() {
        return new Builder();
    }

    public interface IdStage {
        /**
         * <p>The unique identifier for this split run.</p>
         * <p>Example: <code>&quot;splr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
         */
        StatusStage id(@NotNull String id);

        Builder from(SplitRun other);
    }

    public interface StatusStage {
        ReviewedStage status(@NotNull ProcessorRunStatus status);
    }

    public interface ReviewedStage {
        /**
         * <p>Indicates whether the run has been reviewed by a human.</p>
         */
        EditedStage reviewed(boolean reviewed);
    }

    public interface EditedStage {
        /**
         * <p>Indicates whether the run results have been edited during review.</p>
         */
        ConfigStage edited(boolean edited);
    }

    public interface ConfigStage {
        /**
         * <p>The configuration used for this split run.</p>
         */
        FileStage config(@NotNull SplitConfig config);
    }

    public interface FileStage {
        /**
         * <p>The file that was processed.</p>
         */
        DashboardUrlStage file(@NotNull FileSummary file);
    }

    public interface DashboardUrlStage {
        /**
         * <p>The URL to view the split run in the Extend dashboard.</p>
         */
        CreatedAtStage dashboardUrl(@NotNull String dashboardUrl);
    }

    public interface CreatedAtStage {
        UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt);
    }

    public interface UpdatedAtStage {
        _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt);
    }

    public interface _FinalStage {
        SplitRun build();

        /**
         * <p>The splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         */
        _FinalStage splitter(Optional<SplitterSummary> splitter);

        _FinalStage splitter(SplitterSummary splitter);

        _FinalStage splitter(Nullable<SplitterSummary> splitter);

        /**
         * <p>The version of the splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         */
        _FinalStage splitterVersion(Optional<SplitterVersionSummary> splitterVersion);

        _FinalStage splitterVersion(SplitterVersionSummary splitterVersion);

        _FinalStage splitterVersion(Nullable<SplitterVersionSummary> splitterVersion);

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        _FinalStage output(Optional<SplitOutput> output);

        _FinalStage output(SplitOutput output);

        _FinalStage output(Nullable<SplitOutput> output);

        /**
         * <p>The initial output from the split run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        _FinalStage initialOutput(Optional<SplitOutput> initialOutput);

        _FinalStage initialOutput(SplitOutput initialOutput);

        _FinalStage initialOutput(Nullable<SplitOutput> initialOutput);

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        _FinalStage reviewedOutput(Optional<SplitOutput> reviewedOutput);

        _FinalStage reviewedOutput(SplitOutput reviewedOutput);

        _FinalStage reviewedOutput(Nullable<SplitOutput> reviewedOutput);

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the splitting output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the splitter</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         */
        _FinalStage failureReason(Optional<String> failureReason);

        _FinalStage failureReason(String failureReason);

        _FinalStage failureReason(Nullable<String> failureReason);

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         */
        _FinalStage failureMessage(Optional<String> failureMessage);

        _FinalStage failureMessage(String failureMessage);

        _FinalStage failureMessage(Nullable<String> failureMessage);

        /**
         * <p>Any metadata that was provided when creating the split run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         */
        _FinalStage metadata(Optional<Map<String, Object>> metadata);

        _FinalStage metadata(Map<String, Object> metadata);

        _FinalStage metadata(Nullable<Map<String, Object>> metadata);

        /**
         * <p>The ID of the parse run that was used for this split run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         */
        _FinalStage parseRunId(Optional<String> parseRunId);

        _FinalStage parseRunId(String parseRunId);

        _FinalStage parseRunId(Nullable<String> parseRunId);

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        _FinalStage usage(Optional<RunUsage> usage);

        _FinalStage usage(RunUsage usage);

        _FinalStage usage(Nullable<RunUsage> usage);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder
            implements IdStage,
                    StatusStage,
                    ReviewedStage,
                    EditedStage,
                    ConfigStage,
                    FileStage,
                    DashboardUrlStage,
                    CreatedAtStage,
                    UpdatedAtStage,
                    _FinalStage {
        private String id;

        private ProcessorRunStatus status;

        private boolean reviewed;

        private boolean edited;

        private SplitConfig config;

        private FileSummary file;

        private String dashboardUrl;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Optional<RunUsage> usage = Optional.empty();

        private Optional<String> parseRunId = Optional.empty();

        private Optional<Map<String, Object>> metadata = Optional.empty();

        private Optional<String> failureMessage = Optional.empty();

        private Optional<String> failureReason = Optional.empty();

        private Optional<SplitOutput> reviewedOutput = Optional.empty();

        private Optional<SplitOutput> initialOutput = Optional.empty();

        private Optional<SplitOutput> output = Optional.empty();

        private Optional<SplitterVersionSummary> splitterVersion = Optional.empty();

        private Optional<SplitterSummary> splitter = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(SplitRun other) {
            id(other.getId());
            splitter(other.getSplitter());
            splitterVersion(other.getSplitterVersion());
            status(other.getStatus());
            output(other.getOutput());
            initialOutput(other.getInitialOutput());
            reviewedOutput(other.getReviewedOutput());
            failureReason(other.getFailureReason());
            failureMessage(other.getFailureMessage());
            metadata(other.getMetadata());
            reviewed(other.getReviewed());
            edited(other.getEdited());
            config(other.getConfig());
            file(other.getFile());
            parseRunId(other.getParseRunId());
            dashboardUrl(other.getDashboardUrl());
            usage(other.getUsage());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            return this;
        }

        /**
         * <p>The unique identifier for this split run.</p>
         * <p>Example: <code>&quot;splr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
         * <p>The unique identifier for this split run.</p>
         * <p>Example: <code>&quot;splr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("id")
        public StatusStage id(@NotNull String id) {
            this.id = Objects.requireNonNull(id, "id must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("status")
        public ReviewedStage status(@NotNull ProcessorRunStatus status) {
            this.status = Objects.requireNonNull(status, "status must not be null");
            return this;
        }

        /**
         * <p>Indicates whether the run has been reviewed by a human.</p>
         * <p>Indicates whether the run has been reviewed by a human.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("reviewed")
        public EditedStage reviewed(boolean reviewed) {
            this.reviewed = reviewed;
            return this;
        }

        /**
         * <p>Indicates whether the run results have been edited during review.</p>
         * <p>Indicates whether the run results have been edited during review.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("edited")
        public ConfigStage edited(boolean edited) {
            this.edited = edited;
            return this;
        }

        /**
         * <p>The configuration used for this split run.</p>
         * <p>The configuration used for this split run.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("config")
        public FileStage config(@NotNull SplitConfig config) {
            this.config = Objects.requireNonNull(config, "config must not be null");
            return this;
        }

        /**
         * <p>The file that was processed.</p>
         * <p>The file that was processed.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("file")
        public DashboardUrlStage file(@NotNull FileSummary file) {
            this.file = Objects.requireNonNull(file, "file must not be null");
            return this;
        }

        /**
         * <p>The URL to view the split run in the Extend dashboard.</p>
         * <p>The URL to view the split run in the Extend dashboard.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("dashboardUrl")
        public CreatedAtStage dashboardUrl(@NotNull String dashboardUrl) {
            this.dashboardUrl = Objects.requireNonNull(dashboardUrl, "dashboardUrl must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("createdAt")
        public UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt) {
            this.createdAt = Objects.requireNonNull(createdAt, "createdAt must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("updatedAt")
        public _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt) {
            this.updatedAt = Objects.requireNonNull(updatedAt, "updatedAt must not be null");
            return this;
        }

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage usage(Nullable<RunUsage> usage) {
            if (usage.isNull()) {
                this.usage = null;
            } else if (usage.isEmpty()) {
                this.usage = Optional.empty();
            } else {
                this.usage = Optional.of(usage.get());
            }
            return this;
        }

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage usage(RunUsage usage) {
            this.usage = Optional.ofNullable(usage);
            return this;
        }

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "usage", nulls = Nulls.SKIP)
        public _FinalStage usage(Optional<RunUsage> usage) {
            this.usage = usage;
            return this;
        }

        /**
         * <p>The ID of the parse run that was used for this split run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage parseRunId(Nullable<String> parseRunId) {
            if (parseRunId.isNull()) {
                this.parseRunId = null;
            } else if (parseRunId.isEmpty()) {
                this.parseRunId = Optional.empty();
            } else {
                this.parseRunId = Optional.of(parseRunId.get());
            }
            return this;
        }

        /**
         * <p>The ID of the parse run that was used for this split run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage parseRunId(String parseRunId) {
            this.parseRunId = Optional.ofNullable(parseRunId);
            return this;
        }

        /**
         * <p>The ID of the parse run that was used for this split run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "parseRunId", nulls = Nulls.SKIP)
        public _FinalStage parseRunId(Optional<String> parseRunId) {
            this.parseRunId = parseRunId;
            return this;
        }

        /**
         * <p>Any metadata that was provided when creating the split run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Nullable<Map<String, Object>> metadata) {
            if (metadata.isNull()) {
                this.metadata = null;
            } else if (metadata.isEmpty()) {
                this.metadata = Optional.empty();
            } else {
                this.metadata = Optional.of(metadata.get());
            }
            return this;
        }

        /**
         * <p>Any metadata that was provided when creating the split run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Map<String, Object> metadata) {
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * <p>Any metadata that was provided when creating the split run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "metadata", nulls = Nulls.SKIP)
        public _FinalStage metadata(Optional<Map<String, Object>> metadata) {
            this.metadata = metadata;
            return this;
        }

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureMessage(Nullable<String> failureMessage) {
            if (failureMessage.isNull()) {
                this.failureMessage = null;
            } else if (failureMessage.isEmpty()) {
                this.failureMessage = Optional.empty();
            } else {
                this.failureMessage = Optional.of(failureMessage.get());
            }
            return this;
        }

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureMessage(String failureMessage) {
            this.failureMessage = Optional.ofNullable(failureMessage);
            return this;
        }

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "failureMessage", nulls = Nulls.SKIP)
        public _FinalStage failureMessage(Optional<String> failureMessage) {
            this.failureMessage = failureMessage;
            return this;
        }

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the splitting output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the splitter</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureReason(Nullable<String> failureReason) {
            if (failureReason.isNull()) {
                this.failureReason = null;
            } else if (failureReason.isEmpty()) {
                this.failureReason = Optional.empty();
            } else {
                this.failureReason = Optional.of(failureReason.get());
            }
            return this;
        }

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the splitting output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the splitter</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureReason(String failureReason) {
            this.failureReason = Optional.ofNullable(failureReason);
            return this;
        }

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the splitting output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the splitter</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "failureReason", nulls = Nulls.SKIP)
        public _FinalStage failureReason(Optional<String> failureReason) {
            this.failureReason = failureReason;
            return this;
        }

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage reviewedOutput(Nullable<SplitOutput> reviewedOutput) {
            if (reviewedOutput.isNull()) {
                this.reviewedOutput = null;
            } else if (reviewedOutput.isEmpty()) {
                this.reviewedOutput = Optional.empty();
            } else {
                this.reviewedOutput = Optional.of(reviewedOutput.get());
            }
            return this;
        }

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage reviewedOutput(SplitOutput reviewedOutput) {
            this.reviewedOutput = Optional.ofNullable(reviewedOutput);
            return this;
        }

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "reviewedOutput", nulls = Nulls.SKIP)
        public _FinalStage reviewedOutput(Optional<SplitOutput> reviewedOutput) {
            this.reviewedOutput = reviewedOutput;
            return this;
        }

        /**
         * <p>The initial output from the split run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage initialOutput(Nullable<SplitOutput> initialOutput) {
            if (initialOutput.isNull()) {
                this.initialOutput = null;
            } else if (initialOutput.isEmpty()) {
                this.initialOutput = Optional.empty();
            } else {
                this.initialOutput = Optional.of(initialOutput.get());
            }
            return this;
        }

        /**
         * <p>The initial output from the split run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage initialOutput(SplitOutput initialOutput) {
            this.initialOutput = Optional.ofNullable(initialOutput);
            return this;
        }

        /**
         * <p>The initial output from the split run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "initialOutput", nulls = Nulls.SKIP)
        public _FinalStage initialOutput(Optional<SplitOutput> initialOutput) {
            this.initialOutput = initialOutput;
            return this;
        }

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage output(Nullable<SplitOutput> output) {
            if (output.isNull()) {
                this.output = null;
            } else if (output.isEmpty()) {
                this.output = Optional.empty();
            } else {
                this.output = Optional.of(output.get());
            }
            return this;
        }

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage output(SplitOutput output) {
            this.output = Optional.ofNullable(output);
            return this;
        }

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "output", nulls = Nulls.SKIP)
        public _FinalStage output(Optional<SplitOutput> output) {
            this.output = output;
            return this;
        }

        /**
         * <p>The version of the splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage splitterVersion(Nullable<SplitterVersionSummary> splitterVersion) {
            if (splitterVersion.isNull()) {
                this.splitterVersion = null;
            } else if (splitterVersion.isEmpty()) {
                this.splitterVersion = Optional.empty();
            } else {
                this.splitterVersion = Optional.of(splitterVersion.get());
            }
            return this;
        }

        /**
         * <p>The version of the splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage splitterVersion(SplitterVersionSummary splitterVersion) {
            this.splitterVersion = Optional.ofNullable(splitterVersion);
            return this;
        }

        /**
         * <p>The version of the splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "splitterVersion", nulls = Nulls.SKIP)
        public _FinalStage splitterVersion(Optional<SplitterVersionSummary> splitterVersion) {
            this.splitterVersion = splitterVersion;
            return this;
        }

        /**
         * <p>The splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage splitter(Nullable<SplitterSummary> splitter) {
            if (splitter.isNull()) {
                this.splitter = null;
            } else if (splitter.isEmpty()) {
                this.splitter = Optional.empty();
            } else {
                this.splitter = Optional.of(splitter.get());
            }
            return this;
        }

        /**
         * <p>The splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage splitter(SplitterSummary splitter) {
            this.splitter = Optional.ofNullable(splitter);
            return this;
        }

        /**
         * <p>The splitter that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when a splitter reference was provided. Not present when using inline <code>config</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "splitter", nulls = Nulls.SKIP)
        public _FinalStage splitter(Optional<SplitterSummary> splitter) {
            this.splitter = splitter;
            return this;
        }

        @java.lang.Override
        public SplitRun build() {
            return new SplitRun(
                    id,
                    splitter,
                    splitterVersion,
                    status,
                    output,
                    initialOutput,
                    reviewedOutput,
                    failureReason,
                    failureMessage,
                    metadata,
                    reviewed,
                    edited,
                    config,
                    file,
                    parseRunId,
                    dashboardUrl,
                    usage,
                    createdAt,
                    updatedAt,
                    additionalProperties);
        }
    }
}
