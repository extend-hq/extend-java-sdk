/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend.types;

import ai.extend.core.Nullable;
import ai.extend.core.NullableNonemptyFilter;
import ai.extend.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ExtractRun.Builder.class)
public final class ExtractRun {
    private final String id;

    private final Optional<ExtractorSummary> extractor;

    private final Optional<ExtractorVersionSummary> extractorVersion;

    private final ProcessorRunStatus status;

    private final Optional<ExtractOutput> output;

    private final Optional<ExtractOutput> initialOutput;

    private final Optional<ExtractOutput> reviewedOutput;

    private final Optional<String> failureReason;

    private final Optional<String> failureMessage;

    private final Optional<Map<String, Object>> metadata;

    private final boolean reviewed;

    private final boolean edited;

    private final Optional<Map<String, Optional<ExtractOutputEdits>>> edits;

    private final ExtractConfig config;

    private final FileSummary file;

    private final Optional<String> parseRunId;

    private final String dashboardUrl;

    private final Optional<RunUsage> usage;

    private final OffsetDateTime createdAt;

    private final OffsetDateTime updatedAt;

    private final Map<String, Object> additionalProperties;

    private ExtractRun(
            String id,
            Optional<ExtractorSummary> extractor,
            Optional<ExtractorVersionSummary> extractorVersion,
            ProcessorRunStatus status,
            Optional<ExtractOutput> output,
            Optional<ExtractOutput> initialOutput,
            Optional<ExtractOutput> reviewedOutput,
            Optional<String> failureReason,
            Optional<String> failureMessage,
            Optional<Map<String, Object>> metadata,
            boolean reviewed,
            boolean edited,
            Optional<Map<String, Optional<ExtractOutputEdits>>> edits,
            ExtractConfig config,
            FileSummary file,
            Optional<String> parseRunId,
            String dashboardUrl,
            Optional<RunUsage> usage,
            OffsetDateTime createdAt,
            OffsetDateTime updatedAt,
            Map<String, Object> additionalProperties) {
        this.id = id;
        this.extractor = extractor;
        this.extractorVersion = extractorVersion;
        this.status = status;
        this.output = output;
        this.initialOutput = initialOutput;
        this.reviewedOutput = reviewedOutput;
        this.failureReason = failureReason;
        this.failureMessage = failureMessage;
        this.metadata = metadata;
        this.reviewed = reviewed;
        this.edited = edited;
        this.edits = edits;
        this.config = config;
        this.file = file;
        this.parseRunId = parseRunId;
        this.dashboardUrl = dashboardUrl;
        this.usage = usage;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The type of object. Will always be <code>&quot;extract_run&quot;</code>.
     */
    @JsonProperty("object")
    public String getObject() {
        return "extract_run";
    }

    /**
     * @return The unique identifier for this extract run.
     * <p>Example: <code>&quot;exr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
     */
    @JsonProperty("id")
    public String getId() {
        return id;
    }

    /**
     * @return The extractor that was used for this run.
     * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
     */
    @JsonIgnore
    public Optional<ExtractorSummary> getExtractor() {
        if (extractor == null) {
            return Optional.empty();
        }
        return extractor;
    }

    /**
     * @return The version of the extractor that was used for this run.
     * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
     */
    @JsonIgnore
    public Optional<ExtractorVersionSummary> getExtractorVersion() {
        if (extractorVersion == null) {
            return Optional.empty();
        }
        return extractorVersion;
    }

    @JsonProperty("status")
    public ProcessorRunStatus getStatus() {
        return status;
    }

    /**
     * @return The final output, either reviewed or initial.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
     */
    @JsonIgnore
    public Optional<ExtractOutput> getOutput() {
        if (output == null) {
            return Optional.empty();
        }
        return output;
    }

    /**
     * @return The initial output from the extract run, before any review edits.
     * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
     */
    @JsonIgnore
    public Optional<ExtractOutput> getInitialOutput() {
        if (initialOutput == null) {
            return Optional.empty();
        }
        return initialOutput;
    }

    /**
     * @return The output after human review.
     * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
     */
    @JsonIgnore
    public Optional<ExtractOutput> getReviewedOutput() {
        if (reviewedOutput == null) {
            return Optional.empty();
        }
        return reviewedOutput;
    }

    /**
     * @return The reason for failure.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
     * <p>Possible values include:</p>
     * <ul>
     * <li><code>ABORTED</code> - The run was aborted by the user</li>
     * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
     * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
     * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
     * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
     * <li><code>PARSING_ERROR</code> - Failed to parse the extraction output</li>
     * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing (e.g., chunking)</li>
     * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
     * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the extraction</li>
     * </ul>
     * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
     */
    @JsonIgnore
    public Optional<String> getFailureReason() {
        if (failureReason == null) {
            return Optional.empty();
        }
        return failureReason;
    }

    /**
     * @return A detailed message about the failure.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
     */
    @JsonIgnore
    public Optional<String> getFailureMessage() {
        if (failureMessage == null) {
            return Optional.empty();
        }
        return failureMessage;
    }

    /**
     * @return Any metadata that was provided when creating the extract run.
     * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
     */
    @JsonIgnore
    public Optional<Map<String, Object>> getMetadata() {
        if (metadata == null) {
            return Optional.empty();
        }
        return metadata;
    }

    /**
     * @return Indicates whether the run has been reviewed by a human.
     */
    @JsonProperty("reviewed")
    public boolean getReviewed() {
        return reviewed;
    }

    /**
     * @return Indicates whether the run results have been edited during review.
     */
    @JsonProperty("edited")
    public boolean getEdited() {
        return edited;
    }

    /**
     * @return Details of edits made during review.
     * <p><strong>Availability:</strong> Present when <code>edited</code> is <code>true</code>.</p>
     */
    @JsonIgnore
    public Optional<Map<String, Optional<ExtractOutputEdits>>> getEdits() {
        if (edits == null) {
            return Optional.empty();
        }
        return edits;
    }

    /**
     * @return The configuration used for this extract run.
     */
    @JsonProperty("config")
    public ExtractConfig getConfig() {
        return config;
    }

    /**
     * @return The file that was processed.
     */
    @JsonProperty("file")
    public FileSummary getFile() {
        return file;
    }

    /**
     * @return The ID of the parse run that was used for this extract run.
     * <p><strong>Availability:</strong> Present when a parse run was created.</p>
     */
    @JsonIgnore
    public Optional<String> getParseRunId() {
        if (parseRunId == null) {
            return Optional.empty();
        }
        return parseRunId;
    }

    /**
     * @return The URL to view the extract run in the Extend dashboard.
     */
    @JsonProperty("dashboardUrl")
    public String getDashboardUrl() {
        return dashboardUrl;
    }

    /**
     * @return Usage credits consumed by this run.
     * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
     */
    @JsonIgnore
    public Optional<RunUsage> getUsage() {
        if (usage == null) {
            return Optional.empty();
        }
        return usage;
    }

    @JsonProperty("createdAt")
    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    @JsonProperty("updatedAt")
    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("extractor")
    private Optional<ExtractorSummary> _getExtractor() {
        return extractor;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("extractorVersion")
    private Optional<ExtractorVersionSummary> _getExtractorVersion() {
        return extractorVersion;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("output")
    private Optional<ExtractOutput> _getOutput() {
        return output;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("initialOutput")
    private Optional<ExtractOutput> _getInitialOutput() {
        return initialOutput;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("reviewedOutput")
    private Optional<ExtractOutput> _getReviewedOutput() {
        return reviewedOutput;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("failureReason")
    private Optional<String> _getFailureReason() {
        return failureReason;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("failureMessage")
    private Optional<String> _getFailureMessage() {
        return failureMessage;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("metadata")
    private Optional<Map<String, Object>> _getMetadata() {
        return metadata;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("edits")
    private Optional<Map<String, Optional<ExtractOutputEdits>>> _getEdits() {
        return edits;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("parseRunId")
    private Optional<String> _getParseRunId() {
        return parseRunId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("usage")
    private Optional<RunUsage> _getUsage() {
        return usage;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ExtractRun && equalTo((ExtractRun) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ExtractRun other) {
        return id.equals(other.id)
                && extractor.equals(other.extractor)
                && extractorVersion.equals(other.extractorVersion)
                && status.equals(other.status)
                && output.equals(other.output)
                && initialOutput.equals(other.initialOutput)
                && reviewedOutput.equals(other.reviewedOutput)
                && failureReason.equals(other.failureReason)
                && failureMessage.equals(other.failureMessage)
                && metadata.equals(other.metadata)
                && reviewed == other.reviewed
                && edited == other.edited
                && edits.equals(other.edits)
                && config.equals(other.config)
                && file.equals(other.file)
                && parseRunId.equals(other.parseRunId)
                && dashboardUrl.equals(other.dashboardUrl)
                && usage.equals(other.usage)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.id,
                this.extractor,
                this.extractorVersion,
                this.status,
                this.output,
                this.initialOutput,
                this.reviewedOutput,
                this.failureReason,
                this.failureMessage,
                this.metadata,
                this.reviewed,
                this.edited,
                this.edits,
                this.config,
                this.file,
                this.parseRunId,
                this.dashboardUrl,
                this.usage,
                this.createdAt,
                this.updatedAt);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static IdStage builder() {
        return new Builder();
    }

    public interface IdStage {
        /**
         * <p>The unique identifier for this extract run.</p>
         * <p>Example: <code>&quot;exr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
         */
        StatusStage id(@NotNull String id);

        Builder from(ExtractRun other);
    }

    public interface StatusStage {
        ReviewedStage status(@NotNull ProcessorRunStatus status);
    }

    public interface ReviewedStage {
        /**
         * <p>Indicates whether the run has been reviewed by a human.</p>
         */
        EditedStage reviewed(boolean reviewed);
    }

    public interface EditedStage {
        /**
         * <p>Indicates whether the run results have been edited during review.</p>
         */
        ConfigStage edited(boolean edited);
    }

    public interface ConfigStage {
        /**
         * <p>The configuration used for this extract run.</p>
         */
        FileStage config(@NotNull ExtractConfig config);
    }

    public interface FileStage {
        /**
         * <p>The file that was processed.</p>
         */
        DashboardUrlStage file(@NotNull FileSummary file);
    }

    public interface DashboardUrlStage {
        /**
         * <p>The URL to view the extract run in the Extend dashboard.</p>
         */
        CreatedAtStage dashboardUrl(@NotNull String dashboardUrl);
    }

    public interface CreatedAtStage {
        UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt);
    }

    public interface UpdatedAtStage {
        _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt);
    }

    public interface _FinalStage {
        ExtractRun build();

        /**
         * <p>The extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         */
        _FinalStage extractor(Optional<ExtractorSummary> extractor);

        _FinalStage extractor(ExtractorSummary extractor);

        _FinalStage extractor(Nullable<ExtractorSummary> extractor);

        /**
         * <p>The version of the extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         */
        _FinalStage extractorVersion(Optional<ExtractorVersionSummary> extractorVersion);

        _FinalStage extractorVersion(ExtractorVersionSummary extractorVersion);

        _FinalStage extractorVersion(Nullable<ExtractorVersionSummary> extractorVersion);

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        _FinalStage output(Optional<ExtractOutput> output);

        _FinalStage output(ExtractOutput output);

        _FinalStage output(Nullable<ExtractOutput> output);

        /**
         * <p>The initial output from the extract run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        _FinalStage initialOutput(Optional<ExtractOutput> initialOutput);

        _FinalStage initialOutput(ExtractOutput initialOutput);

        _FinalStage initialOutput(Nullable<ExtractOutput> initialOutput);

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        _FinalStage reviewedOutput(Optional<ExtractOutput> reviewedOutput);

        _FinalStage reviewedOutput(ExtractOutput reviewedOutput);

        _FinalStage reviewedOutput(Nullable<ExtractOutput> reviewedOutput);

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the extraction output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing (e.g., chunking)</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the extraction</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         */
        _FinalStage failureReason(Optional<String> failureReason);

        _FinalStage failureReason(String failureReason);

        _FinalStage failureReason(Nullable<String> failureReason);

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         */
        _FinalStage failureMessage(Optional<String> failureMessage);

        _FinalStage failureMessage(String failureMessage);

        _FinalStage failureMessage(Nullable<String> failureMessage);

        /**
         * <p>Any metadata that was provided when creating the extract run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         */
        _FinalStage metadata(Optional<Map<String, Object>> metadata);

        _FinalStage metadata(Map<String, Object> metadata);

        _FinalStage metadata(Nullable<Map<String, Object>> metadata);

        /**
         * <p>Details of edits made during review.</p>
         * <p><strong>Availability:</strong> Present when <code>edited</code> is <code>true</code>.</p>
         */
        _FinalStage edits(Optional<Map<String, Optional<ExtractOutputEdits>>> edits);

        _FinalStage edits(Map<String, Optional<ExtractOutputEdits>> edits);

        _FinalStage edits(Nullable<Map<String, Optional<ExtractOutputEdits>>> edits);

        /**
         * <p>The ID of the parse run that was used for this extract run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         */
        _FinalStage parseRunId(Optional<String> parseRunId);

        _FinalStage parseRunId(String parseRunId);

        _FinalStage parseRunId(Nullable<String> parseRunId);

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        _FinalStage usage(Optional<RunUsage> usage);

        _FinalStage usage(RunUsage usage);

        _FinalStage usage(Nullable<RunUsage> usage);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder
            implements IdStage,
                    StatusStage,
                    ReviewedStage,
                    EditedStage,
                    ConfigStage,
                    FileStage,
                    DashboardUrlStage,
                    CreatedAtStage,
                    UpdatedAtStage,
                    _FinalStage {
        private String id;

        private ProcessorRunStatus status;

        private boolean reviewed;

        private boolean edited;

        private ExtractConfig config;

        private FileSummary file;

        private String dashboardUrl;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Optional<RunUsage> usage = Optional.empty();

        private Optional<String> parseRunId = Optional.empty();

        private Optional<Map<String, Optional<ExtractOutputEdits>>> edits = Optional.empty();

        private Optional<Map<String, Object>> metadata = Optional.empty();

        private Optional<String> failureMessage = Optional.empty();

        private Optional<String> failureReason = Optional.empty();

        private Optional<ExtractOutput> reviewedOutput = Optional.empty();

        private Optional<ExtractOutput> initialOutput = Optional.empty();

        private Optional<ExtractOutput> output = Optional.empty();

        private Optional<ExtractorVersionSummary> extractorVersion = Optional.empty();

        private Optional<ExtractorSummary> extractor = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(ExtractRun other) {
            id(other.getId());
            extractor(other.getExtractor());
            extractorVersion(other.getExtractorVersion());
            status(other.getStatus());
            output(other.getOutput());
            initialOutput(other.getInitialOutput());
            reviewedOutput(other.getReviewedOutput());
            failureReason(other.getFailureReason());
            failureMessage(other.getFailureMessage());
            metadata(other.getMetadata());
            reviewed(other.getReviewed());
            edited(other.getEdited());
            edits(other.getEdits());
            config(other.getConfig());
            file(other.getFile());
            parseRunId(other.getParseRunId());
            dashboardUrl(other.getDashboardUrl());
            usage(other.getUsage());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            return this;
        }

        /**
         * <p>The unique identifier for this extract run.</p>
         * <p>Example: <code>&quot;exr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
         * <p>The unique identifier for this extract run.</p>
         * <p>Example: <code>&quot;exr_Xj8mK2pL9nR4vT7qY5wZ&quot;</code></p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("id")
        public StatusStage id(@NotNull String id) {
            this.id = Objects.requireNonNull(id, "id must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("status")
        public ReviewedStage status(@NotNull ProcessorRunStatus status) {
            this.status = Objects.requireNonNull(status, "status must not be null");
            return this;
        }

        /**
         * <p>Indicates whether the run has been reviewed by a human.</p>
         * <p>Indicates whether the run has been reviewed by a human.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("reviewed")
        public EditedStage reviewed(boolean reviewed) {
            this.reviewed = reviewed;
            return this;
        }

        /**
         * <p>Indicates whether the run results have been edited during review.</p>
         * <p>Indicates whether the run results have been edited during review.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("edited")
        public ConfigStage edited(boolean edited) {
            this.edited = edited;
            return this;
        }

        /**
         * <p>The configuration used for this extract run.</p>
         * <p>The configuration used for this extract run.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("config")
        public FileStage config(@NotNull ExtractConfig config) {
            this.config = Objects.requireNonNull(config, "config must not be null");
            return this;
        }

        /**
         * <p>The file that was processed.</p>
         * <p>The file that was processed.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("file")
        public DashboardUrlStage file(@NotNull FileSummary file) {
            this.file = Objects.requireNonNull(file, "file must not be null");
            return this;
        }

        /**
         * <p>The URL to view the extract run in the Extend dashboard.</p>
         * <p>The URL to view the extract run in the Extend dashboard.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("dashboardUrl")
        public CreatedAtStage dashboardUrl(@NotNull String dashboardUrl) {
            this.dashboardUrl = Objects.requireNonNull(dashboardUrl, "dashboardUrl must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("createdAt")
        public UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt) {
            this.createdAt = Objects.requireNonNull(createdAt, "createdAt must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("updatedAt")
        public _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt) {
            this.updatedAt = Objects.requireNonNull(updatedAt, "updatedAt must not be null");
            return this;
        }

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage usage(Nullable<RunUsage> usage) {
            if (usage.isNull()) {
                this.usage = null;
            } else if (usage.isEmpty()) {
                this.usage = Optional.empty();
            } else {
                this.usage = Optional.of(usage.get());
            }
            return this;
        }

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage usage(RunUsage usage) {
            this.usage = Optional.ofNullable(usage);
            return this;
        }

        /**
         * <p>Usage credits consumed by this run.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "usage", nulls = Nulls.SKIP)
        public _FinalStage usage(Optional<RunUsage> usage) {
            this.usage = usage;
            return this;
        }

        /**
         * <p>The ID of the parse run that was used for this extract run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage parseRunId(Nullable<String> parseRunId) {
            if (parseRunId.isNull()) {
                this.parseRunId = null;
            } else if (parseRunId.isEmpty()) {
                this.parseRunId = Optional.empty();
            } else {
                this.parseRunId = Optional.of(parseRunId.get());
            }
            return this;
        }

        /**
         * <p>The ID of the parse run that was used for this extract run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage parseRunId(String parseRunId) {
            this.parseRunId = Optional.ofNullable(parseRunId);
            return this;
        }

        /**
         * <p>The ID of the parse run that was used for this extract run.</p>
         * <p><strong>Availability:</strong> Present when a parse run was created.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "parseRunId", nulls = Nulls.SKIP)
        public _FinalStage parseRunId(Optional<String> parseRunId) {
            this.parseRunId = parseRunId;
            return this;
        }

        /**
         * <p>Details of edits made during review.</p>
         * <p><strong>Availability:</strong> Present when <code>edited</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage edits(Nullable<Map<String, Optional<ExtractOutputEdits>>> edits) {
            if (edits.isNull()) {
                this.edits = null;
            } else if (edits.isEmpty()) {
                this.edits = Optional.empty();
            } else {
                this.edits = Optional.of(edits.get());
            }
            return this;
        }

        /**
         * <p>Details of edits made during review.</p>
         * <p><strong>Availability:</strong> Present when <code>edited</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage edits(Map<String, Optional<ExtractOutputEdits>> edits) {
            this.edits = Optional.ofNullable(edits);
            return this;
        }

        /**
         * <p>Details of edits made during review.</p>
         * <p><strong>Availability:</strong> Present when <code>edited</code> is <code>true</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "edits", nulls = Nulls.SKIP)
        public _FinalStage edits(Optional<Map<String, Optional<ExtractOutputEdits>>> edits) {
            this.edits = edits;
            return this;
        }

        /**
         * <p>Any metadata that was provided when creating the extract run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Nullable<Map<String, Object>> metadata) {
            if (metadata.isNull()) {
                this.metadata = null;
            } else if (metadata.isEmpty()) {
                this.metadata = Optional.empty();
            } else {
                this.metadata = Optional.of(metadata.get());
            }
            return this;
        }

        /**
         * <p>Any metadata that was provided when creating the extract run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Map<String, Object> metadata) {
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * <p>Any metadata that was provided when creating the extract run.</p>
         * <p><strong>Availability:</strong> Present when metadata was provided during creation.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "metadata", nulls = Nulls.SKIP)
        public _FinalStage metadata(Optional<Map<String, Object>> metadata) {
            this.metadata = metadata;
            return this;
        }

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureMessage(Nullable<String> failureMessage) {
            if (failureMessage.isNull()) {
                this.failureMessage = null;
            } else if (failureMessage.isEmpty()) {
                this.failureMessage = Optional.empty();
            } else {
                this.failureMessage = Optional.of(failureMessage.get());
            }
            return this;
        }

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureMessage(String failureMessage) {
            this.failureMessage = Optional.ofNullable(failureMessage);
            return this;
        }

        /**
         * <p>A detailed message about the failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "failureMessage", nulls = Nulls.SKIP)
        public _FinalStage failureMessage(Optional<String> failureMessage) {
            this.failureMessage = failureMessage;
            return this;
        }

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the extraction output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing (e.g., chunking)</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the extraction</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureReason(Nullable<String> failureReason) {
            if (failureReason.isNull()) {
                this.failureReason = null;
            } else if (failureReason.isEmpty()) {
                this.failureReason = Optional.empty();
            } else {
                this.failureReason = Optional.of(failureReason.get());
            }
            return this;
        }

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the extraction output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing (e.g., chunking)</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the extraction</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage failureReason(String failureReason) {
            this.failureReason = Optional.ofNullable(failureReason);
            return this;
        }

        /**
         * <p>The reason for failure.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;FAILED&quot;</code>.</p>
         * <p>Possible values include:</p>
         * <ul>
         * <li><code>ABORTED</code> - The run was aborted by the user</li>
         * <li><code>INTERNAL_ERROR</code> - An unexpected internal error occurred</li>
         * <li><code>FAILED_TO_PROCESS_FILE</code> - Failed to process the file (e.g., OCR failure, file access issues)</li>
         * <li><code>INVALID_PROCESSOR</code> - The processor configuration is invalid</li>
         * <li><code>INVALID_CONFIGURATION</code> - The provided configuration is incompatible with the selected model</li>
         * <li><code>PARSING_ERROR</code> - Failed to parse the extraction output</li>
         * <li><code>PRE_PROCESSING_FAILURE</code> - An error occurred during preprocessing (e.g., chunking)</li>
         * <li><code>POST_PROCESSING_FAILURE</code> - An error occurred during postprocessing</li>
         * <li><code>OUT_OF_CREDITS</code> - Insufficient credits to run the extraction</li>
         * </ul>
         * <p><strong>Note:</strong> Additional failure reasons may be added in the future. Your integration should handle unknown values gracefully.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "failureReason", nulls = Nulls.SKIP)
        public _FinalStage failureReason(Optional<String> failureReason) {
            this.failureReason = failureReason;
            return this;
        }

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage reviewedOutput(Nullable<ExtractOutput> reviewedOutput) {
            if (reviewedOutput.isNull()) {
                this.reviewedOutput = null;
            } else if (reviewedOutput.isEmpty()) {
                this.reviewedOutput = Optional.empty();
            } else {
                this.reviewedOutput = Optional.of(reviewedOutput.get());
            }
            return this;
        }

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage reviewedOutput(ExtractOutput reviewedOutput) {
            this.reviewedOutput = Optional.ofNullable(reviewedOutput);
            return this;
        }

        /**
         * <p>The output after human review.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "reviewedOutput", nulls = Nulls.SKIP)
        public _FinalStage reviewedOutput(Optional<ExtractOutput> reviewedOutput) {
            this.reviewedOutput = reviewedOutput;
            return this;
        }

        /**
         * <p>The initial output from the extract run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage initialOutput(Nullable<ExtractOutput> initialOutput) {
            if (initialOutput.isNull()) {
                this.initialOutput = null;
            } else if (initialOutput.isEmpty()) {
                this.initialOutput = Optional.empty();
            } else {
                this.initialOutput = Optional.of(initialOutput.get());
            }
            return this;
        }

        /**
         * <p>The initial output from the extract run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage initialOutput(ExtractOutput initialOutput) {
            this.initialOutput = Optional.ofNullable(initialOutput);
            return this;
        }

        /**
         * <p>The initial output from the extract run, before any review edits.</p>
         * <p><strong>Availability:</strong> Present when <code>reviewed</code> is <code>true</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "initialOutput", nulls = Nulls.SKIP)
        public _FinalStage initialOutput(Optional<ExtractOutput> initialOutput) {
            this.initialOutput = initialOutput;
            return this;
        }

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage output(Nullable<ExtractOutput> output) {
            if (output.isNull()) {
                this.output = null;
            } else if (output.isEmpty()) {
                this.output = Optional.empty();
            } else {
                this.output = Optional.of(output.get());
            }
            return this;
        }

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage output(ExtractOutput output) {
            this.output = Optional.ofNullable(output);
            return this;
        }

        /**
         * <p>The final output, either reviewed or initial.</p>
         * <p><strong>Availability:</strong> Present when <code>status</code> is <code>&quot;PROCESSED&quot;</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "output", nulls = Nulls.SKIP)
        public _FinalStage output(Optional<ExtractOutput> output) {
            this.output = output;
            return this;
        }

        /**
         * <p>The version of the extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage extractorVersion(Nullable<ExtractorVersionSummary> extractorVersion) {
            if (extractorVersion.isNull()) {
                this.extractorVersion = null;
            } else if (extractorVersion.isEmpty()) {
                this.extractorVersion = Optional.empty();
            } else {
                this.extractorVersion = Optional.of(extractorVersion.get());
            }
            return this;
        }

        /**
         * <p>The version of the extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage extractorVersion(ExtractorVersionSummary extractorVersion) {
            this.extractorVersion = Optional.ofNullable(extractorVersion);
            return this;
        }

        /**
         * <p>The version of the extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "extractorVersion", nulls = Nulls.SKIP)
        public _FinalStage extractorVersion(Optional<ExtractorVersionSummary> extractorVersion) {
            this.extractorVersion = extractorVersion;
            return this;
        }

        /**
         * <p>The extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage extractor(Nullable<ExtractorSummary> extractor) {
            if (extractor.isNull()) {
                this.extractor = null;
            } else if (extractor.isEmpty()) {
                this.extractor = Optional.empty();
            } else {
                this.extractor = Optional.of(extractor.get());
            }
            return this;
        }

        /**
         * <p>The extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage extractor(ExtractorSummary extractor) {
            this.extractor = Optional.ofNullable(extractor);
            return this;
        }

        /**
         * <p>The extractor that was used for this run.</p>
         * <p><strong>Availability:</strong> Present when an extractor reference was provided. Not present when using inline <code>config</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "extractor", nulls = Nulls.SKIP)
        public _FinalStage extractor(Optional<ExtractorSummary> extractor) {
            this.extractor = extractor;
            return this;
        }

        @java.lang.Override
        public ExtractRun build() {
            return new ExtractRun(
                    id,
                    extractor,
                    extractorVersion,
                    status,
                    output,
                    initialOutput,
                    reviewedOutput,
                    failureReason,
                    failureMessage,
                    metadata,
                    reviewed,
                    edited,
                    edits,
                    config,
                    file,
                    parseRunId,
                    dashboardUrl,
                    usage,
                    createdAt,
                    updatedAt,
                    additionalProperties);
        }
    }
}
