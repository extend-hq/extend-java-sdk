/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend;

import ai.extend.core.ClientOptions;
import ai.extend.core.ExtendClientApiException;
import ai.extend.core.ExtendClientException;
import ai.extend.core.ExtendClientHttpResponse;
import ai.extend.core.MediaTypes;
import ai.extend.core.ObjectMappers;
import ai.extend.core.QueryStringMapper;
import ai.extend.core.RequestOptions;
import ai.extend.errors.BadRequestError;
import ai.extend.errors.UnauthorizedError;
import ai.extend.errors.UnprocessableEntityError;
import ai.extend.requests.ParseAsyncRequest;
import ai.extend.requests.ParseRequest;
import ai.extend.types.Error;
import ai.extend.types.ParserRun;
import ai.extend.types.ParserRunStatus;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class RawExtendClient {
    protected final ClientOptions clientOptions;

    public RawExtendClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Parse files to get cleaned, chunked target content (e.g. markdown).
     * <p>The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>For more details, see the <a href="/product/parsing/parse">Parse File guide</a>.</p>
     */
    public ExtendClientHttpResponse<ParserRun> parse(ParseRequest request) {
        return parse(request, null);
    }

    /**
     * Parse files to get cleaned, chunked target content (e.g. markdown).
     * <p>The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>For more details, see the <a href="/product/parsing/parse">Parse File guide</a>.</p>
     */
    public ExtendClientHttpResponse<ParserRun> parse(ParseRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("parse");
        if (request.getResponseType().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "responseType", request.getResponseType().get(), false);
        }
        Map<String, Object> properties = new HashMap<>();
        properties.put("file", request.getFile());
        if (request.getConfig().isPresent()) {
            properties.put("config", request.getConfig());
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(properties), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new ExtendClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ParserRun.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 401:
                        throw new UnauthorizedError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class), response);
                    case 422:
                        throw new UnprocessableEntityError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new ExtendClientApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new ExtendClientException("Network error executing HTTP request", e);
        }
    }

    /**
     * Parse files <strong>asynchronously</strong> to get cleaned, chunked target content (e.g. markdown).
     * <p>The Parse Async endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>Parse files asynchronously and get a parser run ID that can be used to check status and retrieve results with the <a href="https://docs.extend.ai/2025-04-21/developers/api-reference/parse-endpoints/get-parser-run">Get Parser Run</a> endpoint.</p>
     * <p>This is useful for:</p>
     * <ul>
     * <li>Large files that may take longer to process</li>
     * <li>Avoiding timeout issues with synchronous parsing.</li>
     * </ul>
     * <p>For more details, see the <a href="/product/parsing/parse">Parse File guide</a>.</p>
     */
    public ExtendClientHttpResponse<ParserRunStatus> parseAsync(ParseAsyncRequest request) {
        return parseAsync(request, null);
    }

    /**
     * Parse files <strong>asynchronously</strong> to get cleaned, chunked target content (e.g. markdown).
     * <p>The Parse Async endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>Parse files asynchronously and get a parser run ID that can be used to check status and retrieve results with the <a href="https://docs.extend.ai/2025-04-21/developers/api-reference/parse-endpoints/get-parser-run">Get Parser Run</a> endpoint.</p>
     * <p>This is useful for:</p>
     * <ul>
     * <li>Large files that may take longer to process</li>
     * <li>Avoiding timeout issues with synchronous parsing.</li>
     * </ul>
     * <p>For more details, see the <a href="/product/parsing/parse">Parse File guide</a>.</p>
     */
    public ExtendClientHttpResponse<ParserRunStatus> parseAsync(
            ParseAsyncRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("parse/async")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new ExtendClientException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new ExtendClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ParserRunStatus.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 401:
                        throw new UnauthorizedError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Error.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new ExtendClientApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new ExtendClientException("Network error executing HTTP request", e);
        }
    }
}
