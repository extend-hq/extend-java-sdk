/**
 * This file was auto-generated by Fern from our API Definition.
 */
package ai.extend;

import ai.extend.core.ClientOptions;
import ai.extend.core.RequestOptions;
import ai.extend.core.Suppliers;
import ai.extend.requests.ClassifyRequest;
import ai.extend.requests.EditRequest;
import ai.extend.requests.ExtractRequest;
import ai.extend.requests.ParseRequest;
import ai.extend.requests.SplitRequest;
import ai.extend.resources.batchprocessorrun.AsyncBatchProcessorRunClient;
import ai.extend.resources.classifiers.AsyncClassifiersClient;
import ai.extend.resources.classifierversions.AsyncClassifierVersionsClient;
import ai.extend.resources.classifyruns.AsyncClassifyRunsClient;
import ai.extend.resources.editruns.AsyncEditRunsClient;
import ai.extend.resources.evaluationsetitems.AsyncEvaluationSetItemsClient;
import ai.extend.resources.evaluationsetruns.AsyncEvaluationSetRunsClient;
import ai.extend.resources.evaluationsets.AsyncEvaluationSetsClient;
import ai.extend.resources.extractors.AsyncExtractorsClient;
import ai.extend.resources.extractorversions.AsyncExtractorVersionsClient;
import ai.extend.resources.extractruns.AsyncExtractRunsClient;
import ai.extend.resources.files.AsyncFilesClient;
import ai.extend.resources.parseruns.AsyncParseRunsClient;
import ai.extend.resources.processor.AsyncProcessorClient;
import ai.extend.resources.processorrun.AsyncProcessorRunClient;
import ai.extend.resources.processorversion.AsyncProcessorVersionClient;
import ai.extend.resources.splitruns.AsyncSplitRunsClient;
import ai.extend.resources.splitters.AsyncSplittersClient;
import ai.extend.resources.splitterversions.AsyncSplitterVersionsClient;
import ai.extend.resources.workflowruns.AsyncWorkflowRunsClient;
import ai.extend.resources.workflows.AsyncWorkflowsClient;
import ai.extend.types.ClassifyRun;
import ai.extend.types.EditRun;
import ai.extend.types.ExtractRun;
import ai.extend.types.ParseRun;
import ai.extend.types.SplitRun;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

public class AsyncExtendClient {
    protected final ClientOptions clientOptions;

    private final AsyncRawExtendClient rawClient;

    protected final Supplier<AsyncFilesClient> filesClient;

    protected final Supplier<AsyncParseRunsClient> parseRunsClient;

    protected final Supplier<AsyncEditRunsClient> editRunsClient;

    protected final Supplier<AsyncExtractRunsClient> extractRunsClient;

    protected final Supplier<AsyncExtractorsClient> extractorsClient;

    protected final Supplier<AsyncExtractorVersionsClient> extractorVersionsClient;

    protected final Supplier<AsyncClassifyRunsClient> classifyRunsClient;

    protected final Supplier<AsyncClassifiersClient> classifiersClient;

    protected final Supplier<AsyncClassifierVersionsClient> classifierVersionsClient;

    protected final Supplier<AsyncSplitRunsClient> splitRunsClient;

    protected final Supplier<AsyncSplittersClient> splittersClient;

    protected final Supplier<AsyncSplitterVersionsClient> splitterVersionsClient;

    protected final Supplier<AsyncWorkflowsClient> workflowsClient;

    protected final Supplier<AsyncWorkflowRunsClient> workflowRunsClient;

    protected final Supplier<AsyncProcessorRunClient> processorRunClient;

    protected final Supplier<AsyncProcessorClient> processorClient;

    protected final Supplier<AsyncProcessorVersionClient> processorVersionClient;

    protected final Supplier<AsyncBatchProcessorRunClient> batchProcessorRunClient;

    protected final Supplier<AsyncEvaluationSetsClient> evaluationSetsClient;

    protected final Supplier<AsyncEvaluationSetItemsClient> evaluationSetItemsClient;

    protected final Supplier<AsyncEvaluationSetRunsClient> evaluationSetRunsClient;

    public AsyncExtendClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
        this.rawClient = new AsyncRawExtendClient(clientOptions);
        this.filesClient = Suppliers.memoize(() -> new AsyncFilesClient(clientOptions));
        this.parseRunsClient = Suppliers.memoize(() -> new AsyncParseRunsClient(clientOptions));
        this.editRunsClient = Suppliers.memoize(() -> new AsyncEditRunsClient(clientOptions));
        this.extractRunsClient = Suppliers.memoize(() -> new AsyncExtractRunsClient(clientOptions));
        this.extractorsClient = Suppliers.memoize(() -> new AsyncExtractorsClient(clientOptions));
        this.extractorVersionsClient = Suppliers.memoize(() -> new AsyncExtractorVersionsClient(clientOptions));
        this.classifyRunsClient = Suppliers.memoize(() -> new AsyncClassifyRunsClient(clientOptions));
        this.classifiersClient = Suppliers.memoize(() -> new AsyncClassifiersClient(clientOptions));
        this.classifierVersionsClient = Suppliers.memoize(() -> new AsyncClassifierVersionsClient(clientOptions));
        this.splitRunsClient = Suppliers.memoize(() -> new AsyncSplitRunsClient(clientOptions));
        this.splittersClient = Suppliers.memoize(() -> new AsyncSplittersClient(clientOptions));
        this.splitterVersionsClient = Suppliers.memoize(() -> new AsyncSplitterVersionsClient(clientOptions));
        this.workflowsClient = Suppliers.memoize(() -> new AsyncWorkflowsClient(clientOptions));
        this.workflowRunsClient = Suppliers.memoize(() -> new AsyncWorkflowRunsClient(clientOptions));
        this.processorRunClient = Suppliers.memoize(() -> new AsyncProcessorRunClient(clientOptions));
        this.processorClient = Suppliers.memoize(() -> new AsyncProcessorClient(clientOptions));
        this.processorVersionClient = Suppliers.memoize(() -> new AsyncProcessorVersionClient(clientOptions));
        this.batchProcessorRunClient = Suppliers.memoize(() -> new AsyncBatchProcessorRunClient(clientOptions));
        this.evaluationSetsClient = Suppliers.memoize(() -> new AsyncEvaluationSetsClient(clientOptions));
        this.evaluationSetItemsClient = Suppliers.memoize(() -> new AsyncEvaluationSetItemsClient(clientOptions));
        this.evaluationSetRunsClient = Suppliers.memoize(() -> new AsyncEvaluationSetRunsClient(clientOptions));
    }

    /**
     * Get responses with HTTP metadata like headers
     */
    public AsyncRawExtendClient withRawResponse() {
        return this.rawClient;
    }

    /**
     * Parse a file synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /parse_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/parsing/parse">Parse File guide</a>.</p>
     */
    public CompletableFuture<ParseRun> parse(ParseRequest request) {
        return this.rawClient.parse(request).thenApply(response -> response.body());
    }

    /**
     * Parse a file synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /parse_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/parsing/parse">Parse File guide</a>.</p>
     */
    public CompletableFuture<ParseRun> parse(ParseRequest request, RequestOptions requestOptions) {
        return this.rawClient.parse(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Edit a file synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /edit_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Edit endpoint allows you to detect and fill form fields in PDF documents.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/editing/edit">Edit File guide</a>.</p>
     */
    public CompletableFuture<EditRun> edit(EditRequest request) {
        return this.rawClient.edit(request).thenApply(response -> response.body());
    }

    /**
     * Edit a file synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /edit_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Edit endpoint allows you to detect and fill form fields in PDF documents.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/editing/edit">Edit File guide</a>.</p>
     */
    public CompletableFuture<EditRun> edit(EditRequest request, RequestOptions requestOptions) {
        return this.rawClient.edit(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Extract structured data from a file synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /extract_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Extract endpoint allows you to extract structured data from files using an existing extractor or an inline configuration.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/extracting/extract">Extract File guide</a>.</p>
     */
    public CompletableFuture<ExtractRun> extract(ExtractRequest request) {
        return this.rawClient.extract(request).thenApply(response -> response.body());
    }

    /**
     * Extract structured data from a file synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /extract_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Extract endpoint allows you to extract structured data from files using an existing extractor or an inline configuration.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/extracting/extract">Extract File guide</a>.</p>
     */
    public CompletableFuture<ExtractRun> extract(ExtractRequest request, RequestOptions requestOptions) {
        return this.rawClient.extract(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Classify a document synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /classify_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Classify endpoint allows you to classify documents using an existing classifier or an inline configuration.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/classifying/classify">Classify File guide</a>.</p>
     */
    public CompletableFuture<ClassifyRun> classify(ClassifyRequest request) {
        return this.rawClient.classify(request).thenApply(response -> response.body());
    }

    /**
     * Classify a document synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /classify_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Classify endpoint allows you to classify documents using an existing classifier or an inline configuration.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/classifying/classify">Classify File guide</a>.</p>
     */
    public CompletableFuture<ClassifyRun> classify(ClassifyRequest request, RequestOptions requestOptions) {
        return this.rawClient.classify(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Split a document synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /split_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Split endpoint allows you to split documents into multiple parts using an existing splitter or an inline configuration.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/splitting/split">Split File guide</a>.</p>
     */
    public CompletableFuture<SplitRun> split(SplitRequest request) {
        return this.rawClient.split(request).thenApply(response -> response.body());
    }

    /**
     * Split a document synchronously, waiting for the result before returning. This endpoint has a <strong>5-minute timeout</strong> — if processing takes longer, the request will fail.
     * <p><strong>Note:</strong> This endpoint is intended for onboarding and testing only. For production workloads, use <code>POST /split_runs</code> with webhooks or polling instead, as it provides better reliability for large files and avoids timeout issues.</p>
     * <p>The Split endpoint allows you to split documents into multiple parts using an existing splitter or an inline configuration.</p>
     * <p>For more details, see the <a href="https://docs.extend.ai/2026-02-09/product/splitting/split">Split File guide</a>.</p>
     */
    public CompletableFuture<SplitRun> split(SplitRequest request, RequestOptions requestOptions) {
        return this.rawClient.split(request, requestOptions).thenApply(response -> response.body());
    }

    public AsyncFilesClient files() {
        return this.filesClient.get();
    }

    public AsyncParseRunsClient parseRuns() {
        return this.parseRunsClient.get();
    }

    public AsyncEditRunsClient editRuns() {
        return this.editRunsClient.get();
    }

    public AsyncExtractRunsClient extractRuns() {
        return this.extractRunsClient.get();
    }

    public AsyncExtractorsClient extractors() {
        return this.extractorsClient.get();
    }

    public AsyncExtractorVersionsClient extractorVersions() {
        return this.extractorVersionsClient.get();
    }

    public AsyncClassifyRunsClient classifyRuns() {
        return this.classifyRunsClient.get();
    }

    public AsyncClassifiersClient classifiers() {
        return this.classifiersClient.get();
    }

    public AsyncClassifierVersionsClient classifierVersions() {
        return this.classifierVersionsClient.get();
    }

    public AsyncSplitRunsClient splitRuns() {
        return this.splitRunsClient.get();
    }

    public AsyncSplittersClient splitters() {
        return this.splittersClient.get();
    }

    public AsyncSplitterVersionsClient splitterVersions() {
        return this.splitterVersionsClient.get();
    }

    public AsyncWorkflowsClient workflows() {
        return this.workflowsClient.get();
    }

    public AsyncWorkflowRunsClient workflowRuns() {
        return this.workflowRunsClient.get();
    }

    public AsyncProcessorRunClient processorRun() {
        return this.processorRunClient.get();
    }

    public AsyncProcessorClient processor() {
        return this.processorClient.get();
    }

    public AsyncProcessorVersionClient processorVersion() {
        return this.processorVersionClient.get();
    }

    public AsyncBatchProcessorRunClient batchProcessorRun() {
        return this.batchProcessorRunClient.get();
    }

    public AsyncEvaluationSetsClient evaluationSets() {
        return this.evaluationSetsClient.get();
    }

    public AsyncEvaluationSetItemsClient evaluationSetItems() {
        return this.evaluationSetItemsClient.get();
    }

    public AsyncEvaluationSetRunsClient evaluationSetRuns() {
        return this.evaluationSetRunsClient.get();
    }

    public static AsyncExtendClientBuilder builder() {
        return new AsyncExtendClientBuilder();
    }
}
