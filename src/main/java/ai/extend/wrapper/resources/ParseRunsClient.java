/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.resources;

import ai.extend.core.ClientOptions;
import ai.extend.resources.parseruns.requests.ParseRunsCreateRequest;
import ai.extend.types.ParseRun;
import ai.extend.types.ParseRunStatusEnum;
import ai.extend.wrapper.utilities.polling.Polling;
import ai.extend.wrapper.utilities.polling.PollingOptions;
import java.util.HashSet;
import java.util.Set;

/**
 * Extended ParseRuns client with polling functionality.
 *
 * <p>Extends the generated {@link ai.extend.resources.parseruns.ParseRunsClient},
 * so all standard methods (create, retrieve, delete) are inherited.
 * Adds {@code createAndPoll} for convenience.</p>
 */
public class ParseRunsClient extends ai.extend.resources.parseruns.ParseRunsClient {

    private static final Set<ParseRunStatusEnum> NON_TERMINAL_STATUSES;

    static {
        NON_TERMINAL_STATUSES = new HashSet<ParseRunStatusEnum>();
        NON_TERMINAL_STATUSES.add(ParseRunStatusEnum.PROCESSING);
    }

    public ParseRunsClient(ClientOptions clientOptions) {
        super(clientOptions);
    }

    /**
     * Creates a parse run and polls until it reaches a terminal state.
     *
     * <p>Terminal states: PROCESSED, FAILED</p>
     */
    public ParseRun createAndPoll(ParseRunsCreateRequest request) {
        return createAndPoll(request, PollingOptions.defaults());
    }

    /**
     * Creates a parse run and polls until it reaches a terminal state.
     *
     * <p>Terminal states: PROCESSED, FAILED</p>
     */
    public ParseRun createAndPoll(ParseRunsCreateRequest request, PollingOptions options) {

        ParseRun createResponse = this.create(request);
        final String runId = createResponse.getId();

        return Polling.pollUntilDone(
                () -> this.retrieve(runId), response -> isTerminalStatus(response.getStatus()), options);
    }

    private boolean isTerminalStatus(ParseRunStatusEnum status) {
        return !NON_TERMINAL_STATUSES.contains(status);
    }
}
