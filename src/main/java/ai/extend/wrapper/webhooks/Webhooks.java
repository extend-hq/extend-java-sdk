/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.webhooks;

import ai.extend.core.ObjectMappers;
import ai.extend.types.WebhookEvent;
import ai.extend.wrapper.errors.SignedUrlNotAllowedError;
import ai.extend.wrapper.errors.WebhookPayloadFetchError;
import ai.extend.wrapper.errors.WebhookSignatureVerificationError;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.Closeable;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

/**
 * Utility class for verifying and parsing webhook events.
 *
 * <p>This class provides methods to verify webhook signatures, parse webhook
 * bodies, and handle signed URL payloads.</p>
 *
 * <h3>Basic Usage</h3>
 * <pre>{@code
 * Webhooks webhooks = new Webhooks();
 *
 * // Verify and parse a webhook (throws if signed URL received)
 * WebhookEvent event = webhooks.verifyAndParse(body, headers, signingSecret);
 * event.visit(new WebhookEvent.Visitor&lt;Void&gt;() { ... });
 * }</pre>
 *
 * <h3>Handling Signed URLs</h3>
 * <pre>{@code
 * RawWebhookEvent raw = webhooks.verifyAndParseWithOptions(body, headers, signingSecret,
 *     VerifyAndParseOptions.builder().allowSignedUrl(true).build());
 * if (raw.isSignedUrlEvent()) {
 *     WebhookEvent fullEvent = webhooks.fetchSignedPayload(raw.getSignedUrlEvent());
 * } else {
 *     WebhookEvent event = raw.getEvent();
 * }
 * }</pre>
 */
public class Webhooks implements Closeable {

    private static final String TIMESTAMP_HEADER = "x-extend-request-timestamp";
    private static final String SIGNATURE_HEADER = "x-extend-request-signature";
    private static final int CLOCK_SKEW_TOLERANCE_SECONDS = 60;
    private static final int DEFAULT_TIMEOUT_SECONDS = 30;

    private final OkHttpClient httpClient;
    private final boolean ownsHttpClient;

    public Webhooks() {
        this.httpClient = new OkHttpClient.Builder()
                .connectTimeout(DEFAULT_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .readTimeout(DEFAULT_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .writeTimeout(DEFAULT_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .build();
        this.ownsHttpClient = true;
    }

    /**
     * Creates a new Webhooks instance with a custom OkHttpClient.
     *
     * <p>Use this constructor to customize timeouts, proxy settings, or connection pool
     * configuration. The provided client will not be closed when {@link #close()} is called.</p>
     *
     * @param httpClient The OkHttpClient to use for fetching signed URL payloads
     */
    public Webhooks(OkHttpClient httpClient) {
        this.httpClient = httpClient;
        this.ownsHttpClient = false;
    }

    /**
     * Closes the underlying HTTP client if it was created by this instance.
     *
     * <p>If a custom OkHttpClient was provided via {@link #Webhooks(OkHttpClient)},
     * this method does nothing (the caller is responsible for closing their client).</p>
     */
    @Override
    public void close() {
        if (ownsHttpClient) {
            httpClient.dispatcher().executorService().shutdown();
            httpClient.connectionPool().evictAll();
        }
    }

    /**
     * Verifies the webhook signature and parses the event.
     *
     * <p>Throws {@link SignedUrlNotAllowedError} if a signed URL payload is received.
     * Use {@link #verifyAndParseWithOptions} with {@code allowSignedUrl=true} to handle
     * signed URL payloads.</p>
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers (case-insensitive lookup supported)
     * @param signingSecret The webhook signing secret from the Extend dashboard
     * @return The parsed typed webhook event
     * @throws WebhookSignatureVerificationError if signature verification fails
     * @throws SignedUrlNotAllowedError if a signed URL payload is received
     */
    public WebhookEvent verifyAndParse(String body, Map<String, String> headers, String signingSecret)
            throws WebhookSignatureVerificationError, SignedUrlNotAllowedError {
        RawWebhookEvent raw =
                verifyAndParseWithOptions(body, headers, signingSecret, VerifyAndParseOptions.defaults());
        return raw.getEvent();
    }

    /**
     * Verifies the webhook signature and parses the event with options.
     *
     * <p>Returns a {@link RawWebhookEvent} (union of typed event or signed URL event), matching
     * the TypeScript and Python SDKs. Use {@link RawWebhookEvent#isSignedUrlEvent()} to narrow,
     * then {@link RawWebhookEvent#getEvent()} or {@link RawWebhookEvent#getSignedUrlEvent()}.</p>
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers (case-insensitive lookup supported)
     * @param signingSecret The webhook signing secret from the Extend dashboard
     * @param options       Verification and parsing options
     * @return A raw webhook event (either normal or signed URL)
     * @throws WebhookSignatureVerificationError if signature verification fails
     * @throws SignedUrlNotAllowedError if signed URL received without allowSignedUrl=true
     */
    public RawWebhookEvent verifyAndParseWithOptions(
            String body, Map<String, String> headers, String signingSecret, VerifyAndParseOptions options)
            throws WebhookSignatureVerificationError, SignedUrlNotAllowedError {

        verifySignature(body, headers, signingSecret, options.toVerifyOptions());

        Map<String, Object> eventMap = parseJsonBody(body);
        Map<String, Object> payload = safeGetMap(eventMap, "payload");

        if (isSignedDataUrlPayload(payload)) {
            if (!options.isAllowSignedUrl()) {
                throw new SignedUrlNotAllowedError();
            }
            return VerifyAndParseResult.ofSignedUrlEvent(parseAsSignedUrlEvent(eventMap));
        }

        WebhookEvent webhookEvent = parseAsWebhookEvent(body);
        String eventId = safeGetString(eventMap, "eventId");
        String eventType = safeGetString(eventMap, "eventType");
        return VerifyAndParseResult.ofEvent(webhookEvent, eventId, eventType);
    }

    /**
     * Verifies the webhook signature without parsing.
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers
     * @param signingSecret The webhook signing secret
     * @return true if the signature is valid, false otherwise
     */
    public boolean verify(String body, Map<String, String> headers, String signingSecret) {
        return verify(body, headers, signingSecret, VerifyOptions.defaults());
    }

    /**
     * Verifies the webhook signature without parsing.
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers
     * @param signingSecret The webhook signing secret
     * @param options       Verification options
     * @return true if the signature is valid, false otherwise
     */
    public boolean verify(String body, Map<String, String> headers, String signingSecret, VerifyOptions options) {
        try {
            verifySignature(body, headers, signingSecret, options);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Parses the webhook body without verification.
     *
     * <p><strong>Warning:</strong> Only use this after separately verifying the signature
     * with {@link #verify}.</p>
     *
     * @param body The raw request body as a string
     * @return A raw webhook event (either normal or signed URL)
     */
    public RawWebhookEvent parse(String body) {
        Map<String, Object> eventMap = parseJsonBody(body);
        Map<String, Object> payload = safeGetMap(eventMap, "payload");

        if (isSignedDataUrlPayload(payload)) {
            return VerifyAndParseResult.ofSignedUrlEvent(parseAsSignedUrlEvent(eventMap));
        }

        WebhookEvent webhookEvent = parseAsWebhookEvent(body);
        String eventId = safeGetString(eventMap, "eventId");
        String eventType = safeGetString(eventMap, "eventType");
        return VerifyAndParseResult.ofEvent(webhookEvent, eventId, eventType);
    }

    /**
     * Fetches the full payload from a signed URL event.
     *
     * @param event The webhook event with a signed URL payload
     * @return The full typed webhook event with resolved payload
     * @throws WebhookPayloadFetchError if the fetch fails
     */
    public WebhookEvent fetchSignedPayload(WebhookEventWithSignedUrl event) throws WebhookPayloadFetchError {
        String url = event.getPayload().getData();

        Request request = new Request.Builder().url(url).get().build();

        try (Response response = httpClient.newCall(request).execute()) {

            if (!response.isSuccessful()) {
                throw new WebhookPayloadFetchError(
                        String.format("Failed to fetch signed payload: HTTP %d", response.code()));
            }

            String responseBody = response.body() != null ? response.body().string() : "";

            JsonNode fullPayload = ObjectMappers.JSON_MAPPER.readTree(responseBody);

            // Build full event tree and deserialize to typed WebhookEvent
            ObjectNode fullEvent = ObjectMappers.JSON_MAPPER.createObjectNode();
            fullEvent.put("eventId", event.getEventId());
            fullEvent.put("eventType", event.getEventType());
            fullEvent.set("payload", fullPayload);
            return ObjectMappers.JSON_MAPPER.treeToValue(fullEvent, WebhookEvent.class);

        } catch (WebhookPayloadFetchError e) {
            throw e;
        } catch (Exception e) {
            throw new WebhookPayloadFetchError("Failed to fetch signed payload: " + e.getMessage(), e);
        }
    }

    // ========== Private Methods ==========

    private void verifySignature(String body, Map<String, String> headers, String signingSecret, VerifyOptions options)
            throws WebhookSignatureVerificationError {

        String timestamp = getHeader(headers, TIMESTAMP_HEADER);
        String signature = getHeader(headers, SIGNATURE_HEADER);

        if (timestamp == null || timestamp.isEmpty()) {
            throw new WebhookSignatureVerificationError("Missing x-extend-request-timestamp header");
        }

        if (signature == null || signature.isEmpty()) {
            throw new WebhookSignatureVerificationError("Missing x-extend-request-signature header");
        }

        if (signingSecret == null || signingSecret.isEmpty()) {
            throw new WebhookSignatureVerificationError("Missing signing secret");
        }

        // Validate timestamp
        int maxAgeSeconds = options.getMaxAgeSeconds();
        if (maxAgeSeconds > 0) {
            long currentTime = System.currentTimeMillis() / 1000;
            long requestTime;
            try {
                requestTime = Long.parseLong(timestamp);
            } catch (NumberFormatException e) {
                throw new WebhookSignatureVerificationError("Invalid timestamp format");
            }

            long age = currentTime - requestTime;
            if (age > maxAgeSeconds) {
                throw new WebhookSignatureVerificationError(
                        String.format("Request timestamp too old (%ds > %ds)", age, maxAgeSeconds));
            }

            if (age < -CLOCK_SKEW_TOLERANCE_SECONDS) {
                throw new WebhookSignatureVerificationError("Request timestamp in the future");
            }
        }

        // Compute expected signature: HMAC-SHA256(secret, "v0:{timestamp}:{body}")
        String message = String.format("v0:%s:%s", timestamp, body);
        String expectedSignature = computeHmacSha256(signingSecret, message);

        // Constant-time comparison
        if (!MessageDigest.isEqual(
                signature.getBytes(StandardCharsets.UTF_8), expectedSignature.getBytes(StandardCharsets.UTF_8))) {
            throw new WebhookSignatureVerificationError("Invalid signature");
        }
    }

    private String getHeader(Map<String, String> headers, String name) {
        // Try exact match first
        String value = headers.get(name);
        if (value != null) {
            return value;
        }

        // Try lowercase
        value = headers.get(name.toLowerCase());
        if (value != null) {
            return value;
        }

        // Try case-insensitive search
        for (Map.Entry<String, String> entry : headers.entrySet()) {
            if (entry.getKey().equalsIgnoreCase(name)) {
                return entry.getValue();
            }
        }

        return null;
    }

    private String computeHmacSha256(String secret, String message) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            mac.init(keySpec);
            byte[] hash = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (Exception e) {
            throw new WebhookSignatureVerificationError("Failed to compute HMAC", e);
        }
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    private Map<String, Object> parseJsonBody(String body) {
        try {
            return ObjectMappers.JSON_MAPPER.readValue(body, new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            throw new WebhookSignatureVerificationError("Failed to parse webhook body as JSON", e);
        }
    }

    private WebhookEvent parseAsWebhookEvent(String body) {
        try {
            return ObjectMappers.JSON_MAPPER.readValue(body, WebhookEvent.class);
        } catch (Exception e) {
            throw new WebhookSignatureVerificationError("Failed to parse webhook body as WebhookEvent", e);
        }
    }

    private boolean isSignedDataUrlPayload(Map<String, Object> payload) {
        return payload != null
                && "signed_data_url".equals(payload.get("object"))
                && payload.get("data") instanceof String;
    }

    private WebhookEventWithSignedUrl parseAsSignedUrlEvent(Map<String, Object> event) {
        String eventId = safeGetString(event, "eventId");
        String eventType = safeGetString(event, "eventType");
        Map<String, Object> payloadMap = safeGetMap(event, "payload");

        if (payloadMap == null) {
            throw new WebhookSignatureVerificationError("Missing payload in webhook event");
        }

        SignedDataUrlPayload payload = new SignedDataUrlPayload(
                safeGetString(payloadMap, "data"),
                safeGetString(payloadMap, "id"),
                safeGetString(payloadMap, "object"),
                safeGetMap(payloadMap, "metadata"));

        return new WebhookEventWithSignedUrl(eventId, eventType, payload);
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> safeGetMap(Map<String, Object> map, String field) {
        Object value = map.get(field);
        if (value == null) {
            return null;
        }
        if (!(value instanceof Map)) {
            throw new WebhookSignatureVerificationError(
                    String.format("Expected '%s' to be an object, got %s", field, value.getClass().getSimpleName()));
        }
        return (Map<String, Object>) value;
    }

    private String safeGetString(Map<String, Object> map, String field) {
        Object value = map.get(field);
        if (value == null) {
            return null;
        }
        if (value instanceof String) {
            return (String) value;
        }
        return String.valueOf(value);
    }
}
