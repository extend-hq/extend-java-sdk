/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.webhooks;

import ai.extend.core.ObjectMappers;
import ai.extend.wrapper.errors.SignedUrlNotAllowedError;
import ai.extend.wrapper.errors.WebhookPayloadFetchError;
import ai.extend.wrapper.errors.WebhookSignatureVerificationError;
import com.fasterxml.jackson.core.type.TypeReference;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.HashMap;
import java.util.Map;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

/**
 * Utility class for verifying and parsing webhook events.
 * 
 * <p>This class provides methods to verify webhook signatures, parse webhook
 * bodies, and handle signed URL payloads.</p>
 * 
 * <h3>Basic Usage</h3>
 * <pre>{@code
 * Webhooks webhooks = new Webhooks();
 * 
 * // Verify and parse a webhook
 * Map<String, Object> event = webhooks.verifyAndParse(body, headers, signingSecret);
 * }</pre>
 * 
 * <h3>Handling Signed URLs</h3>
 * <pre>{@code
 * Object result = webhooks.verifyAndParse(body, headers, signingSecret,
 *     VerifyAndParseOptions.builder().allowSignedUrl(true).build());
 * 
 * if (webhooks.isSignedUrlEvent(result)) {
 *     WebhookEventWithSignedUrl signedEvent = (WebhookEventWithSignedUrl) result;
 *     Map<String, Object> fullEvent = webhooks.fetchSignedPayload(signedEvent);
 * }
 * }</pre>
 */
public class Webhooks {
    
    private static final String TIMESTAMP_HEADER = "x-extend-request-timestamp";
    private static final String SIGNATURE_HEADER = "x-extend-request-signature";
    private static final int CLOCK_SKEW_TOLERANCE_SECONDS = 60;
    
    private final OkHttpClient httpClient;
    
    public Webhooks() {
        this.httpClient = new OkHttpClient();
    }
    
    /**
     * Verifies the webhook signature and parses the event.
     * 
     * <p>Throws {@link SignedUrlNotAllowedError} if a signed URL payload is received.</p>
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers (case-insensitive lookup supported)
     * @param signingSecret The webhook signing secret from the Extend dashboard
     * @return The parsed webhook event
     * @throws WebhookSignatureVerificationError if signature verification fails
     * @throws SignedUrlNotAllowedError if a signed URL payload is received
     */
    @SuppressWarnings("unchecked")
    public Map<String, Object> verifyAndParse(
            String body,
            Map<String, String> headers,
            String signingSecret) throws WebhookSignatureVerificationError, SignedUrlNotAllowedError {
        Object result = verifyAndParse(body, headers, signingSecret, VerifyAndParseOptions.defaults());
        return (Map<String, Object>) result;
    }
    
    /**
     * Verifies the webhook signature and parses the event with options.
     * 
     * <p>If {@code allowSignedUrl} is true, may return a {@link WebhookEventWithSignedUrl}.
     * Use {@link #isSignedUrlEvent} to check the return type.</p>
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers (case-insensitive lookup supported)
     * @param signingSecret The webhook signing secret from the Extend dashboard
     * @param options       Verification and parsing options
     * @return The parsed webhook event, or {@link WebhookEventWithSignedUrl} if signed URL
     * @throws WebhookSignatureVerificationError if signature verification fails
     * @throws SignedUrlNotAllowedError if signed URL received without allowSignedUrl=true
     */
    @SuppressWarnings("unchecked")
    public Object verifyAndParse(
            String body,
            Map<String, String> headers,
            String signingSecret,
            VerifyAndParseOptions options) throws WebhookSignatureVerificationError, SignedUrlNotAllowedError {
        
        verifySignature(body, headers, signingSecret, options.toVerifyOptions());
        
        Map<String, Object> event = parseJsonBody(body);
        Map<String, Object> payload = (Map<String, Object>) event.get("payload");
        
        if (isSignedDataUrlPayload(payload)) {
            if (!options.isAllowSignedUrl()) {
                throw new SignedUrlNotAllowedError();
            }
            return parseAsSignedUrlEvent(event);
        }
        
        return event;
    }
    
    /**
     * Verifies the webhook signature without parsing.
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers
     * @param signingSecret The webhook signing secret
     * @return true if the signature is valid, false otherwise
     */
    public boolean verify(String body, Map<String, String> headers, String signingSecret) {
        return verify(body, headers, signingSecret, VerifyOptions.defaults());
    }
    
    /**
     * Verifies the webhook signature without parsing.
     *
     * @param body          The raw request body as a string
     * @param headers       The request headers
     * @param signingSecret The webhook signing secret
     * @param options       Verification options
     * @return true if the signature is valid, false otherwise
     */
    public boolean verify(
            String body,
            Map<String, String> headers,
            String signingSecret,
            VerifyOptions options) {
        try {
            verifySignature(body, headers, signingSecret, options);
            return true;
        } catch (WebhookSignatureVerificationError e) {
            return false;
        }
    }
    
    /**
     * Parses the webhook body without verification.
     * 
     * <p><strong>Warning:</strong> Only use this after separately verifying the signature
     * with {@link #verify}.</p>
     *
     * @param body The raw request body as a string
     * @return The parsed event, which may be a {@link WebhookEventWithSignedUrl}
     */
    @SuppressWarnings("unchecked")
    public Object parse(String body) {
        Map<String, Object> event = parseJsonBody(body);
        Map<String, Object> payload = (Map<String, Object>) event.get("payload");
        
        if (isSignedDataUrlPayload(payload)) {
            return parseAsSignedUrlEvent(event);
        }
        
        return event;
    }
    
    /**
     * Fetches the full payload from a signed URL event.
     *
     * @param event The webhook event with a signed URL payload
     * @return The full webhook event with resolved payload
     * @throws WebhookPayloadFetchError if the fetch fails
     */
    @SuppressWarnings("unchecked")
    public Map<String, Object> fetchSignedPayload(WebhookEventWithSignedUrl event) 
            throws WebhookPayloadFetchError {
        String url = event.getPayload().getData();
        
        Request request = new Request.Builder()
            .url(url)
            .get()
            .build();
        
        try {
            Response response = httpClient.newCall(request).execute();
            
            if (!response.isSuccessful()) {
                throw new WebhookPayloadFetchError(
                    String.format("Failed to fetch signed payload: HTTP %d", response.code()));
            }
            
            String responseBody = response.body() != null ? response.body().string() : "";
            
            Map<String, Object> fullPayload = ObjectMappers.JSON_MAPPER.readValue(
                responseBody, new TypeReference<Map<String, Object>>() {});
            
            // Return full event with resolved payload
            Map<String, Object> result = new HashMap<String, Object>();
            result.put("eventId", event.getEventId());
            result.put("eventType", event.getEventType());
            result.put("payload", fullPayload);
            return result;
            
        } catch (WebhookPayloadFetchError e) {
            throw e;
        } catch (Exception e) {
            throw new WebhookPayloadFetchError("Failed to fetch signed payload: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if the event is a signed URL event.
     *
     * @param event The parsed event (from verifyAndParse or parse)
     * @return true if the event is a {@link WebhookEventWithSignedUrl}
     */
    public boolean isSignedUrlEvent(Object event) {
        return event instanceof WebhookEventWithSignedUrl;
    }
    
    // ========== Private Methods ==========
    
    private void verifySignature(
            String body,
            Map<String, String> headers,
            String signingSecret,
            VerifyOptions options) throws WebhookSignatureVerificationError {
        
        String timestamp = getHeader(headers, TIMESTAMP_HEADER);
        String signature = getHeader(headers, SIGNATURE_HEADER);
        
        if (timestamp == null || timestamp.isEmpty()) {
            throw new WebhookSignatureVerificationError("Missing x-extend-request-timestamp header");
        }
        
        if (signature == null || signature.isEmpty()) {
            throw new WebhookSignatureVerificationError("Missing x-extend-request-signature header");
        }
        
        if (signingSecret == null || signingSecret.isEmpty()) {
            throw new WebhookSignatureVerificationError("Missing signing secret");
        }
        
        // Validate timestamp
        int maxAgeSeconds = options.getMaxAgeSeconds();
        if (maxAgeSeconds > 0) {
            long currentTime = System.currentTimeMillis() / 1000;
            long requestTime;
            try {
                requestTime = Long.parseLong(timestamp);
            } catch (NumberFormatException e) {
                throw new WebhookSignatureVerificationError("Invalid timestamp format");
            }
            
            long age = currentTime - requestTime;
            if (age > maxAgeSeconds) {
                throw new WebhookSignatureVerificationError(
                    String.format("Request timestamp too old (%ds > %ds)", age, maxAgeSeconds));
            }
            
            if (age < -CLOCK_SKEW_TOLERANCE_SECONDS) {
                throw new WebhookSignatureVerificationError("Request timestamp in the future");
            }
        }
        
        // Compute expected signature: HMAC-SHA256(secret, "v0:{timestamp}:{body}")
        String message = String.format("v0:%s:%s", timestamp, body);
        String expectedSignature = computeHmacSha256(signingSecret, message);
        
        // Constant-time comparison
        if (!MessageDigest.isEqual(
                signature.getBytes(StandardCharsets.UTF_8), 
                expectedSignature.getBytes(StandardCharsets.UTF_8))) {
            throw new WebhookSignatureVerificationError("Invalid signature");
        }
    }
    
    private String getHeader(Map<String, String> headers, String name) {
        // Try exact match first
        String value = headers.get(name);
        if (value != null) {
            // Handle array values (some frameworks pass arrays)
            if (value.startsWith("[") && value.endsWith("]")) {
                value = value.substring(1, value.length() - 1);
            }
            return value;
        }
        
        // Try lowercase
        value = headers.get(name.toLowerCase());
        if (value != null) {
            if (value.startsWith("[") && value.endsWith("]")) {
                value = value.substring(1, value.length() - 1);
            }
            return value;
        }
        
        // Try case-insensitive search
        for (Map.Entry<String, String> entry : headers.entrySet()) {
            if (entry.getKey().equalsIgnoreCase(name)) {
                value = entry.getValue();
                if (value.startsWith("[") && value.endsWith("]")) {
                    value = value.substring(1, value.length() - 1);
                }
                return value;
            }
        }
        
        return null;
    }
    
    private String computeHmacSha256(String secret, String message) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec keySpec = new SecretKeySpec(
                secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            mac.init(keySpec);
            byte[] hash = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (Exception e) {
            throw new RuntimeException("Failed to compute HMAC", e);
        }
    }
    
    private String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
    
    private Map<String, Object> parseJsonBody(String body) {
        try {
            return ObjectMappers.JSON_MAPPER.readValue(
                body, new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse webhook body as JSON", e);
        }
    }
    
    private boolean isSignedDataUrlPayload(Map<String, Object> payload) {
        return payload != null 
            && "signed_data_url".equals(payload.get("object"))
            && payload.get("data") instanceof String;
    }
    
    @SuppressWarnings("unchecked")
    private WebhookEventWithSignedUrl parseAsSignedUrlEvent(Map<String, Object> event) {
        String eventId = (String) event.get("eventId");
        String eventType = (String) event.get("eventType");
        Map<String, Object> payloadMap = (Map<String, Object>) event.get("payload");
        
        SignedDataUrlPayload payload = new SignedDataUrlPayload(
            (String) payloadMap.get("data"),
            (String) payloadMap.get("id"),
            (String) payloadMap.get("object"),
            (Map<String, Object>) payloadMap.get("metadata")
        );
        
        return new WebhookEventWithSignedUrl(eventId, eventType, payload);
    }
}
