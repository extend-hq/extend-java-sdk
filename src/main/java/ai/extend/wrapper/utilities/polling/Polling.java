/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.utilities.polling;

import ai.extend.wrapper.errors.PollingTimeoutError;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Utility class for polling operations with hybrid polling strategy.
 *
 * <p>This class provides methods to poll an API endpoint until a terminal
 * condition is met. The default strategy uses fast polling at fixed intervals
 * for an initial period, then switches to exponential backoff with jitter.</p>
 *
 * <p>Default behavior:</p>
 * <ul>
 *   <li>Fast phase: Poll every 1 second for the first 30 seconds</li>
 *   <li>Backoff phase: Exponential backoff with 1.15x multiplier, max 30 second delay</li>
 * </ul>
 */
public final class Polling {

    private Polling() {
        // Utility class - prevent instantiation
    }

    /**
     * Calculates the next delay using exponential backoff with proportional jitter.
     *
     * <p>Formula: min(initialDelay * multiplier^attempt, maxDelay) * (1 + random(-jitter, +jitter))</p>
     *
     * @param attempt           The current attempt number (0-based)
     * @param initialDelayMs    The initial delay in milliseconds
     * @param maxDelayMs        The maximum delay in milliseconds
     * @param jitterFraction    The jitter fraction (e.g., 0.25 for ±25%)
     * @param backoffMultiplier The multiplier for exponential backoff (default: 2.0)
     * @return The calculated delay in milliseconds
     */
    public static int calculateBackoffDelay(
            int attempt,
            int initialDelayMs,
            int maxDelayMs,
            double jitterFraction,
            double backoffMultiplier) {

        // Exponential backoff: initialDelay * multiplier^attempt
        long exponentialDelay = (long) (initialDelayMs * Math.pow(backoffMultiplier, attempt));

        // Cap at maxDelay
        int cappedDelay = (int) Math.min(exponentialDelay, maxDelayMs);

        // Apply proportional jitter: delay * (1 + random(-jitterFraction, +jitterFraction))
        double jitter = (Math.random() * 2 - 1) * jitterFraction;
        double finalDelay = cappedDelay * (1 + jitter);

        return (int) Math.round(finalDelay);
    }

    /**
     * Calculates the next delay using exponential backoff with default 2x multiplier.
     *
     * @param attempt         The current attempt number (0-based)
     * @param initialDelayMs  The initial delay in milliseconds
     * @param maxDelayMs      The maximum delay in milliseconds
     * @param jitterFraction  The jitter fraction (e.g., 0.25 for ±25%)
     * @return The calculated delay in milliseconds
     */
    public static int calculateBackoffDelay(int attempt, int initialDelayMs, int maxDelayMs, double jitterFraction) {
        return calculateBackoffDelay(attempt, initialDelayMs, maxDelayMs, jitterFraction, 2.0);
    }

    /**
     * Calculates the delay for a hybrid polling strategy based on elapsed time.
     *
     * <p>During the fast polling phase (elapsed &lt; fastPollDurationMs), returns a fixed
     * interval with jitter. After the fast phase ends, switches to exponential backoff.</p>
     *
     * @param elapsedMs           Total elapsed time since polling started
     * @param fastPollDurationMs  Duration of fast polling phase in milliseconds
     * @param fastPollIntervalMs  Interval between polls during fast phase in milliseconds
     * @param initialDelayMs      Initial delay for backoff phase in milliseconds
     * @param maxDelayMs          Maximum delay cap in milliseconds
     * @param backoffMultiplier   Multiplier for exponential backoff
     * @param jitterFraction      Jitter fraction for randomization
     * @return The delay in milliseconds until the next poll
     */
    public static int calculateHybridDelay(
            long elapsedMs,
            int fastPollDurationMs,
            int fastPollIntervalMs,
            int initialDelayMs,
            int maxDelayMs,
            double backoffMultiplier,
            double jitterFraction) {

        // Fast polling phase: use fixed interval with jitter
        if (elapsedMs < fastPollDurationMs) {
            double jitter = (Math.random() * 2 - 1) * jitterFraction;
            return (int) Math.round(fastPollIntervalMs * (1 + jitter));
        }

        // Backoff phase: calculate attempt number based on time since fast phase ended
        long timeSinceBackoffStart = elapsedMs - fastPollDurationMs;

        // Calculate which "attempt" we're on based on elapsed time in backoff phase
        // Sum of geometric series: S = a * (r^n - 1) / (r - 1)
        // Solving for n: n = log((S * (r - 1) / a) + 1) / log(r)
        int attempt;
        if (backoffMultiplier == 1.0) {
            // Linear case: attempt = timeSinceBackoffStart / initialDelayMs
            attempt = (int) (timeSinceBackoffStart / initialDelayMs);
        } else {
            double r = backoffMultiplier;
            double a = initialDelayMs;
            double s = timeSinceBackoffStart;

            // Estimate attempt from geometric series sum formula
            double innerValue = (s * (r - 1)) / a + 1;
            if (innerValue <= 0) {
                attempt = 0;
            } else {
                attempt = (int) (Math.log(innerValue) / Math.log(r));
            }
        }

        return calculateBackoffDelay(attempt, initialDelayMs, maxDelayMs, jitterFraction, backoffMultiplier);
    }

    /**
     * Polls a retrieve function until a terminal condition is met.
     *
     * <p>This method uses a hybrid polling strategy: fast polling at fixed intervals
     * for an initial period, then exponential backoff with jitter. This provides low
     * latency for quick operations while still reducing server load for longer ones.</p>
     *
     * <p>Default behavior:</p>
     * <ul>
     *   <li>Fast phase: Poll every 1 second for the first 30 seconds</li>
     *   <li>Backoff phase: Exponential backoff with 1.15x multiplier, max 30 second delay</li>
     * </ul>
     *
     * @param <T>        The type of result returned by the retrieve function
     * @param retrieve   A supplier that retrieves the current state
     * @param isTerminal A predicate that returns true when polling should stop
     * @param options    Polling configuration options
     * @return The final result when a terminal state is reached
     * @throws PollingTimeoutError if maxWaitMs is set and exceeded
     */
    public static <T> T pollUntilDone(Supplier<T> retrieve, Predicate<T> isTerminal, PollingOptions options)
            throws PollingTimeoutError {

        Integer maxWaitMs = options.getMaxWaitMs();
        int fastPollDurationMs = options.getFastPollDurationMs();
        int fastPollIntervalMs = options.getFastPollIntervalMs();
        int initialDelayMs = options.getInitialDelayMs();
        int maxDelayMs = options.getMaxDelayMs();
        double backoffMultiplier = options.getBackoffMultiplier();
        double jitterFraction = options.getJitterFraction();

        long startTime = System.currentTimeMillis();

        while (true) {
            T result = retrieve.get();

            if (isTerminal.test(result)) {
                return result;
            }

            long elapsedMs = System.currentTimeMillis() - startTime;

            // Only check timeout if maxWaitMs is set
            if (maxWaitMs != null && elapsedMs >= maxWaitMs) {
                throw new PollingTimeoutError(
                        String.format("Polling timed out after %dms (max: %dms)", elapsedMs, maxWaitMs),
                        (int) elapsedMs,
                        maxWaitMs);
            }

            int delay = calculateHybridDelay(
                    elapsedMs,
                    fastPollDurationMs,
                    fastPollIntervalMs,
                    initialDelayMs,
                    maxDelayMs,
                    backoffMultiplier,
                    jitterFraction);

            // If timeout is set, don't wait longer than remaining time
            int actualDelay;
            if (maxWaitMs != null) {
                long remainingMs = maxWaitMs - elapsedMs;
                actualDelay = (int) Math.min(delay, remainingMs);
            } else {
                actualDelay = delay;
            }

            try {
                Thread.sleep(actualDelay);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Polling interrupted", e);
            }
        }
    }

    /**
     * Polls a retrieve function until a terminal condition is met, using default options.
     *
     * <p>Polls indefinitely until a terminal state is reached using hybrid polling strategy.</p>
     *
     * @param <T>        The type of result returned by the retrieve function
     * @param retrieve   A supplier that retrieves the current state
     * @param isTerminal A predicate that returns true when polling should stop
     * @return The final result when a terminal state is reached
     */
    public static <T> T pollUntilDone(Supplier<T> retrieve, Predicate<T> isTerminal) {
        return pollUntilDone(retrieve, isTerminal, PollingOptions.defaults());
    }
}
