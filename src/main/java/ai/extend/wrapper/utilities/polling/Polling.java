/**
 * Custom wrapper code - not auto-generated by Fern.
 */
package ai.extend.wrapper.utilities.polling;

import ai.extend.wrapper.errors.PollingTimeoutError;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Utility class for polling operations with exponential backoff.
 *
 * <p>This class provides methods to poll an API endpoint until a terminal
 * condition is met, using exponential backoff with jitter to avoid
 * thundering herd problems.</p>
 */
public final class Polling {

    private Polling() {
        // Utility class - prevent instantiation
    }

    /**
     * Calculates the next delay using exponential backoff with proportional jitter.
     *
     * <p>Formula: min(initialDelay * 2^attempt, maxDelay) * (1 + random(-jitter, +jitter))</p>
     *
     * @param attempt         The current attempt number (0-based)
     * @param initialDelayMs  The initial delay in milliseconds
     * @param maxDelayMs      The maximum delay in milliseconds
     * @param jitterFraction  The jitter fraction (e.g., 0.25 for Â±25%)
     * @return The calculated delay in milliseconds
     */
    public static int calculateBackoffDelay(int attempt, int initialDelayMs, int maxDelayMs, double jitterFraction) {

        // Exponential backoff: initialDelay * 2^attempt
        long exponentialDelay = initialDelayMs * (long) Math.pow(2, attempt);

        // Cap at maxDelay
        int cappedDelay = (int) Math.min(exponentialDelay, maxDelayMs);

        // Apply proportional jitter: delay * (1 + random(-jitterFraction, +jitterFraction))
        double jitter = (Math.random() * 2 - 1) * jitterFraction;
        double finalDelay = cappedDelay * (1 + jitter);

        return (int) Math.round(finalDelay);
    }

    /**
     * Polls a retrieve function until a terminal condition is met.
     *
     * <p>This method repeatedly calls the {@code retrieve} function and checks
     * if the result satisfies the {@code isTerminal} predicate. It uses exponential
     * backoff with jitter between calls.</p>
     *
     * @param <T>        The type of result returned by the retrieve function
     * @param retrieve   A supplier that retrieves the current state
     * @param isTerminal A predicate that returns true when polling should stop
     * @param options    Polling configuration options
     * @return The final result when a terminal state is reached
     * @throws PollingTimeoutError if maxWaitMs is set and exceeded
     */
    public static <T> T pollUntilDone(Supplier<T> retrieve, Predicate<T> isTerminal, PollingOptions options)
            throws PollingTimeoutError {

        Integer maxWaitMs = options.getMaxWaitMs();
        int initialDelayMs = options.getInitialDelayMs();
        int maxDelayMs = options.getMaxDelayMs();
        double jitterFraction = options.getJitterFraction();

        long startTime = System.currentTimeMillis();
        int attempt = 0;

        while (true) {
            T result = retrieve.get();

            if (isTerminal.test(result)) {
                return result;
            }

            long elapsedMs = System.currentTimeMillis() - startTime;

            // Only check timeout if maxWaitMs is set
            if (maxWaitMs != null && elapsedMs >= maxWaitMs) {
                throw new PollingTimeoutError(
                        String.format("Polling timed out after %dms (max: %dms)", elapsedMs, maxWaitMs),
                        (int) elapsedMs,
                        maxWaitMs);
            }

            int delay = calculateBackoffDelay(attempt, initialDelayMs, maxDelayMs, jitterFraction);

            // If timeout is set, don't wait longer than remaining time
            int actualDelay;
            if (maxWaitMs != null) {
                long remainingMs = maxWaitMs - elapsedMs;
                actualDelay = (int) Math.min(delay, remainingMs);
            } else {
                actualDelay = delay;
            }

            try {
                Thread.sleep(actualDelay);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Polling interrupted", e);
            }

            attempt++;
        }
    }

    /**
     * Polls a retrieve function until a terminal condition is met, using default options.
     *
     * <p>Polls indefinitely until a terminal state is reached.</p>
     *
     * @param <T>        The type of result returned by the retrieve function
     * @param retrieve   A supplier that retrieves the current state
     * @param isTerminal A predicate that returns true when polling should stop
     * @return The final result when a terminal state is reached
     */
    public static <T> T pollUntilDone(Supplier<T> retrieve, Predicate<T> isTerminal) {
        return pollUntilDone(retrieve, isTerminal, PollingOptions.defaults());
    }
}
